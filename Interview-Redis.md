# Redis 的过期策略

# 定期删除

## 懒惰删除

## 淘汰策略(LRU和LFU)

LFU 表示按最近的访问频率进行淘汰，它比 LRU 更加精准地表示了一个 key 被访问的热度。

如果一个 key 长时间不被访问，只是刚刚偶然被用户访问了一下，那么在使用 LRU 算法下它是不容易被淘汰的，因为 LRU 算法认为当前这个 key 是很热的。而 LFU 是需要追踪最近一段时间的访问频率，如果某个 key 只是偶然被访问一次是不足以变得很热的，它需要在近期一段时间内被访问很多次才有机会被认为很热。





# 缓存雪崩-- 大量的key同时失效

解决方案:

1. 分散过期时间
2. 在缓存失效之后, 通过加锁或者队列来控制读数据库写缓存的线程数量, 保证同一时间只有一个线程再写数据,其他线程等待
3. 双key策略, 主key设置过期时间,备key永久, 主key过期, 返回备key的内容
4. 后台更新, 定时更新, 消息队列通知更新
# 缓存击穿 -- 频繁访问的热点数据过期

像子弹一样, 集中某一点持续射击

解决方案

1. 数据用不过期, 由后台更新
2. 互斥锁, 保证对于每个key同时只有一个线程去查询后端服务
# 缓存穿透-- 查询不存在数据

解决方案

1. 非法请求的限制
2. 缓存空值或者默认值
3. 使用布隆过滤器快速判断数据是否存在
# 缓存和数据库双写不一致

1. 延时双删策略, 最后一步的删除可以作为异步操作, 就是防止有客户端读取的时候设置了旧值
```plain
1）先删除缓存
2）再写数据库
3）休眠500毫秒（根据具体的业务时间来定）
4）再次删除缓存。
那么，这个500毫秒怎么确定的，具体该休眠多久呢？
读DB并写入redis的时间
需要评估自己的项目的读数据业务逻辑的耗时。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。
当然，这种策略还要考虑 redis 和数据库主从同步的耗时。最后的写数据的休眠时间：则在读数据业务逻辑的耗时的基础上，加上几百ms即可。比如：休眠1秒。
```

2. 先更新数据库，再删除缓存
3. 订阅数据库的 binlog![图片](https://uploader.shimo.im/f/jm1yvv61tqM7pULH.png!thumbnail?fileGuid=QVywkVTdvjVq6r6H)

# 分布式锁实现

## Redis实现

```plain
//获取锁（unique_value可以是UUID等）
SET resource_name unique_value NX PX  30000
//释放锁（lua脚本中，一定要比较value，防止误解锁）
if redis.call("get",KEYS[1]) == ARGV[1] then
    return redis.call("del",KEYS[1])
else
    return 0
end
```
### 获取锁（unique_value可以是UUID等）

```plain
SET resource_name unique_value NX PX  30000
value 要具有唯一性，可以使用UUID.randomUUID().toString()方法生成，用来标识这把锁是属于哪个请求加的，在解锁的时候就可以有依据；
```
### 释放锁

释放锁时要验证 value 值，防止误解锁；

通过 Lua 脚本来避免 Check And Set 模型的并发问题，因为在释放锁的时候因为涉及到多个Redis操作 （利用了eval命令执行Lua脚本的原子性）

### 存在的风险

如果存储锁对应key的那个节点挂了的话，就可能存在丢失锁的风险，导致出现多个客户端持有锁的情况，这样就不能实现资源的独享了。

客户端A从master获取到锁

在master将锁同步到slave之前，master宕掉了（Redis的主从同步通常是异步的）。

主从切换，slave节点被晋级为master节点

客户端B取得了同一个资源被客户端A已经获取到的另外一个锁。导致存在同一时刻存不止一个线程获取到锁的情况。

### redlock算法

```plain
这个场景是假设有一个 redis cluster，有 5 个 redis master 实例。然后执行如下步骤获取一把锁：
1. 获取当前时间戳，单位是毫秒；
2. 跟上面类似，轮流尝试在每个 master 节点上创建锁，过期时间较短，一般就几十毫秒；
3. 尝试在大多数节点上建立一个锁，比如 5 个节点就要求是 3 个节点 n / 2 + 1；
4. 客户端计算建立好锁的时间，如果建立锁的时间小于超时时间，就算建立成功了；
5. 要是锁建立失败了，那么就依次之前建立过的锁删除；
6. 只要别人建立了一把分布式锁，你就得不断轮询去尝试获取锁。
```
































































