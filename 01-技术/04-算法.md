# 设计模式-单例(java)


双重检查


```java
public class Singleton {
    //指向实例的私有静态引用
    private volatile static Singleton singleton;
    //私有构造方法
    private Singleton(){
    }
    //返回唯一实例的静态public方法
    public static Singleton getInstance(){
        if(null==singleton){
            synchronized(Singleton.class){
                if(null==singleton){
                    singleton=new Singleton();
                }
            }
        }
        return singleton;
    }
}
```


懒汉式


```java
public class Singleton4 {
private Singleton4 (){
  
 private static class LazyHolder {
    //final 为了防止内部误操作，代理模式，GgLib的代理模式
    private static final Singleton4 INSTANCE = new Singleton4();
 }
 
 public static final Singleton4 getInstance() {  
    return LazyHolder.INSTANCE;
  }
}
```



# 排序


## 冒泡排序


```java
/**
 * 推荐这个
 * flag 用来做优化
 *
 * 空间复杂度: O(1)
 * 时间复杂度: O(n^2)
 * 稳定的排序算法
 *
 */
private static void maoPao(int[] nums) {
    int count = 0;
    boolean flag = false;
  	int len = nums.length;
    for (int i = 0; i <len- 1; i++) {
        for (int j = 0; j < len - 1 - i; j++) {
            count++;
            if (nums[j] > nums[j + 1]) {
                //交换
                swap(nums, j, j+1);
                // 有交换 设置成 true
                flag = true;
            }
        }
        System.out.println("第" + (i + 1) + "趟排序数组");
        System.out.println(Arrays.toString(nums));
        //优化
        if (flag) {
            flag = false;
        } else {
            break;
        }
    }
    System.out.println("比较次数: " + count);
}
```


## 快排


平均时间复杂度**O(nlogn)**,  最坏的情况**O(n^2), 不稳定排序**


```java
// 非递归写法
private static void quickSort(int[] arr, int left, int right) {
    // 用栈模拟
    Stack<Integer> stack = new Stack<>();
    if (left < right) {
        stack.push(right);
        stack.push(left);
        while (!stack.isEmpty()) {
            int l = stack.pop();
            int r = stack.pop();
            int pivot = Partition(arr, l, r);
            if (l < pivot - 1) {
                stack.push(pivot - 1);
                stack.push(l);
            }
            if (r > pivot + 1) {
                stack.push(r);
                stack.push(pivot + 1);
            }
        }
    }
}
// 递归写法
private static void quickSortV3(int[] arr, int left, int right) {
    // 是否只剩下一个元素
    if (left >= right) {
        // 递归退出
        return;
    }
    // 基准值
    int pivot = partition(arr, left, right);
    quickSortV3(arr, left, pivot - 1);// left ~ pivot-1 的元素都比小
    quickSortV3(arr, pivot + 1, right);
}
//划分方法
  private  int partition(int[] a, int left, int right) {
    int mid = left;
    while(left<right) {
      while(left<right && a[right]>=a[mid]){
        right--;
      }
      while(left<right && a[left]<=a[mid]) {
        left++;
      }
      if(left<right) {
        swap(a,left,right);
      }
    }
    swap(a,mid,left);
    return left;
  }
  
//交换方法
  private static void swap(int[] a, int left, int right) {
    int t = a[left];
    a[left] = a[right];
    a[right] = t;
  }
```


## 面试题排序


给定0，1，2组成的数组，把0，1，2按顺序排列，空间复杂度O(1),时间复杂度O(n)


```java
public static int[] sort(int[] arr) {
    int left = 0;
    int right = arr.length - 1;
    int cur = 0;
    while (cur < right) {
        if (arr[cur] == 0) {
            swap(arr, cur, left);
            left++;
            cur++;
        } else if (arr[cur] == 1) {
            cur++;
        } else if (arr[cur] == 2) {
            swap(arr, cur, right);
            right--;
        }
    }
    return arr;
}
```


## 堆排序

O(nlogk)

大顶堆：每个结点的值都大于或等于其左右孩子结点的值。

 小顶堆：每个结点的值都小于或等于其左右孩子结点的值

只能从堆顶取值


![](https://youpaiyun.zongqilive.cn/image/20210514095225.png#id=uMCGm&originHeight=275&originWidth=825&originalType=binary&status=done&style=none)


## 归并排序


```java
// 归并排序
public static void mergeSort(int[] arr, int start, int end) {
    // 如果 left == right，表示数组只有一个元素，则不用递归排序
    if (start >= end) {
        return;
    }
    // 从中间将数组分成2个部分
    int mid = start + (end - start) / 2;
    // 对左半部分进行排序
    mergeSort(arr, start, mid);
    // 对右半部分进行排序
    mergeSort(arr, mid + 1, end);
    //进行合并
    merge(arr, start, mid, end);
}
// 合并函数，把两个有序的数组合并起来
// arr[left..mid]表示一个数组，arr[mid+1 .. right]表示一个数组
private static void merge(int[] arr, int start, int mid, int end) {
    int leftLen = mid - start + 1;
    int rightLen = end - (mid + 1) + 1;
    int[] L = new int[leftLen];
    int[] R = new int[rightLen];
    for (int i = 0; i < leftLen; i++) {
        L[i] = arr[start + i];
    }
    for (int j = 0; j < rightLen; j++) {
        R[j] = arr[mid + 1 + j];
    }
    // 两个指针
    int l = 0, r = 0, k = start;
    while (l < leftLen && r < rightLen) {
        if (L[l] <= R[r]) {
            arr[k] = L[l];
            l++;
        } else {
            arr[k] = R[r];
            r++;
        }
        k++;
    }
    while (l < leftLen) {
        //左边的有序序列还有剩余的元素，就全部填充到
        arr[k] = L[l];
        k++;
        l++;
    }
    while (r < rightLen) {
        //右边的有序序列还有剩余的元素，就全部填充到
        arr[k] = R[r];
        k++;
        r++;
    }
}
```


# 查找算法

## 二分查找 - 无重复数字

前提是 有序的数组, 时间复杂度 - O(logn)


```java

/**
 * 非递归 推荐这个
 */
public static int binarySearchV3(int[] array, int target) {
    int start = 0;
    int end = array.length - 1;
    while (start <= end) {
        // todo 如果数太大, 两数想加会有溢出问题,
        int mid = start + (end - start) / 2;
        if (array[mid] == target) {
            return mid;
        } else if (array[mid] < target) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return -1;
}
/**
 * 递归的方式
 *
 * @param arr     数组
 * @param start    左边的索引
 * @param end   右边的索引
 * @param target 要查找的值
 * @return 如果找到就返回下标，如果没有找到，就返回 -1
 */
public static int binarySearch(int[] arr, int start, int end, int target) {
    // 当 start > end 时，说明递归整个数组，但是没有找到
    if (start > end) {
        return -1;
    }
    int mid = start + (end - start) / 2;
    if (target > arr[mid]) { // 向 右递归
        return binarySearch(arr, mid + 1, end, target);
    } else if (target < arr[mid]) { // 向左递归
        return binarySearch(arr, start, mid - 1, target);
    } else {
        return mid;
    }
}
```
## 二分查找II_ 有重复数字

```java
public int search(int[] array, int target) {
    int start = 0;
    int end = array.length - 1;
    while (start <= end) {
        int mid = start + (end - start) / 2;
        if (array[mid] == target) {
            //判断mid之前是否有相同元素（即是否是第一个target）
            //mid!=0，注意是!=，这是输出结果的边界条件
            while (mid != 0 && (array[mid - 1] == array[mid])) {
                --mid;
            }
            return mid;
        } else if (array[mid] < target) {
            start = mid + 1;
        } else {
            end = mid - 1;
        }
    }
    return -1;
}
```



# 动态规划


```
动态规划的套路
1. 状态容器
2. 初始化
3. 动态方程
4. 最后结果
https://www.zdaiot.com/DataStructureAlgorithm/40%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%90%86%E8%AE%BA%EF%BC%9A%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82%E6%9C%80%E4%BC%98%E5%AD%90%E7%BB%93%E6%9E%84%E3%80%81%E6%97%A0%E5%90%8E%E6%95%88%E6%80%A7%E5%92%8C%E9%87%8D%E5%A4%8D%E5%AD%90%E9%97%AE%E9%A2%98/
```



## -70-爬楼梯_简单


> **需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？**



![](https://youpaiyun.zongqilive.cn/image/20210514095324.png#id=fDero&originHeight=247&originWidth=328&originalType=binary&status=done&style=none)


上第一个台阶: 1种方法


上第二个台阶: 2种方法


```java
public class Solution_1 {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        // 状态容器
        int[] dp = new int[n];
        // 初始化
        dp[0] = 1;// 上第一个台阶 1种方式
        dp[1] = 2; // 上第二个台阶 2种方式
        // 状态方程
        for (int i = 2; i < n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        // 返回最后一个结果值
        return dp[n - 1];
    }
}
```


## -198-打家劫舍_简单


```java
房子是一排
每间房内都藏有一定的现金, 不能偷取相邻的房间,求能够偷窃到的最高金额
- 输入：[2,7,9,3,1]
- 输出：12
- 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
- 偷窃到的最高金额 = 2 + 9 + 1 = 12 。

public int rob(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int len = nums.length;
    //dp[房子的位置][选择]
    // 状态容器
    int[][] dp = new int[len][2];
    // 初始化
    dp[0][0] = 0; // 不抢
    dp[0][1] = nums[0]; // 抢
    // 状态方程
    for (int i = 1; i < len; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] + nums[i]);
    }
    return Math.max(dp[len - 1][0], dp[len - 1][1]);
}
```


## -213-打家劫舍II_中等

```java
房子不是一排，而是围成了一个圆圈
输入：nums = [1,2,3,1]
输出：4
解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
     偷窃到的最高金额 = 1 + 3 = 4 。
有三种不同情况：
  1-要么都不被抢；(不需要考虑)
  2-要么第一间房子被抢最后一间不抢；
  3-要么最后一间房子被抢第一间不抢
public int rob(int[] nums) {
    if (nums == null || nums.length == 0) return 0;
    int len = nums.length;
    if (len == 1) return nums[0];
    if (len== 2) return Math.max(nums[0], nums[1]);
    return Math.max(help(nums, 0, len - 2), help(nums, 1, len - 1));
}

private int help(int[] nums, int left, int right) {
  // 状态容器
    int[][] dp = new int[right - left + 1][2];
  // 初始化
    dp[0][0] = 0; // 不抢
    dp[0][1] = nums[left]; // 抢
  // 状态方程
    for (int i = left + 1; i <= right; i++) {
        int index = i - left; // 注意下标的处理方式
        dp[index][0] = Math.max(dp[index - 1][0], dp[index - 1][1]);
        dp[index][1] = Math.max(dp[index - 1][1], dp[index - 1][0] + nums[i]);
    }

    return Math.max(dp[right - left][0], dp[right - left][1]);
}
```

## -337-打家劫舍III_中等

```java
房子是一棵二叉树
如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。
输入: [3,2,3,null,3,null,1]
     3
    / \
   2   3
    \   \ 
     3   1
输出: 7 
解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.
// 方法二 动态规划
public int rob(TreeNode root) {
    int[] res = dp(root);
    return Math.max(res[0], res[1]);
}

/* 返回一个大小为 2 的数组 arr
arr[0] 表示不抢 root 的话，得到的最大钱数
arr[1] 表示抢 root 的话，得到的最大钱数 */
public int[] dp(TreeNode root) {
    if (root == null) {
        return new int[]{0, 0};
    }
    int[] left = dp(root.left);
    int[] right = dp(root.right);
    // 抢，下家就不能抢了
    int rob = root.val + left[0] + right[0];
    // 不抢，下家可抢可不抢，取决于收益大小
    int not_rob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    return new int[]{not_rob, rob};
}  

// 方法一 自上往下走
Map<TreeNode, Integer> memo = new HashMap<>();
public int rob(TreeNode root) {
    if (root == null) {
        return 0;
    }
    // 利用备忘录消除重叠子问题
    if (memo.containsKey(root)) {
        return memo.get(root);
    }
    // 抢，然后去下下家
    int do_it = root.val;
    if (root.left != null) {
        do_it+=rob(root.left.left) + rob(root.left.right);
    }
    if (root.right != null) {
        do_it+= rob(root.right.left) + rob(root.right.right);
    }
    // 不抢，然后去下家
    int not_do = rob(root.left) + rob(root.right);

    int res = Math.max(do_it, not_do);
    memo.put(root, res);
    return res;
}
```




## -343-整数拆分_中等


> 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。



## -62-不同路径_中等


![](https://youpaiyun.zongqilive.cn/image/20210514095610.png#id=URawo&originHeight=183&originWidth=400&originalType=binary&status=done&style=none)


> 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角, 问总共有多少条不同的路径



![](https://youpaiyun.zongqilive.cn/image/20210514095620.png#id=brqSP&originHeight=428&originWidth=419&originalType=binary&status=done&style=none)


```java
public int uniquePaths(int m, int n) {
    // 容器
    int[][] dp= new int[m][n];
    // 初始化
    for (int i = 0; i < m; i++) {
        dp[i][0] = 1;
    }
    for (int i = 0; i < n; i++) {
        dp[0][i] = 1;
    }
// 状态方程
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j]+dp[i][j-1];
        }
    }
    return dp[m-1][n-1];
}
```


## -63-不同路径II_中等


有障碍物


```
输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
输出：2
解释：
3x3 网格的正中间有一个障碍物。
从左上角到右下角一共有 2 条不同的路径：
1. 向右 -> 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右 -> 向右
```


```java
public int uniquePathsWithObstacles(int[][] obstacleGrid) {
    // 状态容器
    int m = obstacleGrid.length;
    int n = obstacleGrid[0].length;
    
    int[][] dp = new int[m][n];
    //  初始化, 有障碍物的 值为0 
    for (int i = 0; i < m; i++) {
        if (obstacleGrid[i][0] == 1) {
            // 遇到障碍物, 跳出, 后面的也无法走通了
            break;
        }
        dp[i][0] = 1;
    }
    for (int j = 0; j < n; j++) {
        if (obstacleGrid[0][j] == 1) {
            // 遇到障碍物, 跳出, 后面的也无法走通了
            break;
        }
        dp[0][j] = 1;
    }
    // 状态方程
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (obstacleGrid[i][j] == 1) {
                // 遇到障碍了
                continue;
            }
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    // 获得结果
    return dp[m - 1][n - 1];
}
```


## -322-零钱兑换_中等


```java
给定不同面额的硬币 coins 和一个总金额 amount
最少的硬币个数
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
我们定义一个dp数组，dp[n]表示当前目标金额是n，至少需要dp[n]个硬币凑出该金额
public int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount+1];
    dp[0] = 0;
    // 从1开始
    for (int i = 1; i<= amount; i++) {
        // 这里设置了边界值，用作判定是否能得到对应金额的依据。
        dp[i] = Integer.MAX_VALUE;
        // 遍历零钱数组变量
        for (int coin: coins) {
            // 若零钱值直接大于设定的金额，直接跳过处理
            // i-coin 是其子问题，如果子问题不存在解，也直接跳过
            // if 子句中的比较，是上层循环结果dp[i]与本次逻辑处理结果之间的比较
            if (coin <= i && dp[i-coin] != Integer.MAX_VALUE) {
                dp[i] = Math.min(dp[i], dp[i-coin] + 1);
            }
        }
    }
    return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
}
```

## -518-零钱兑换 II_中等

```java
```



# 子序列和子数组

>  子序列, 子数组, 子集之间的区别
>
> 子数组：一个或连续多个数组中元素组成一个子数组(数组在内存中是连续存储的)
> 子序列：子序列就是在原来序列中找出一部分组成的序列
>
> 假设我们有一个数组：[1, 2, 3, 4, 5]。
>
> [1,2,3]是一个子序列，同时也是一个子数组。
>
> [1,3,5]是一个子序列，但却不是一个子数组，因为子数组要求元素连续。
>
> [3,1,5]是一个子集，但既不是一个子序列，也不是一个子数组。因为后两者都要元素顺序不能改变。


## -392-判断子序列_简单


```java
判断s是否为t的子序列
输入：s = "abc", t = "ahbgdc"
输出：true
// 双指针
public boolean isSubsequence(String s, String t) {
    if (s == null || s.isEmpty()) {
        return true;
    }
    if (s.length() > t.length()) {
        return false;
    }
    char[] ss = s.toCharArray();
    char[] tt = t.toCharArray();
    int ti = 0, si = 0;
    while (ti < tt.length && si < ss.length) {
        if (ss[si] == tt[ti]) {
            ti++;
            si++;
        } else {
            ti++;
        }
    }
    if (si == ss.length) {
        return true;
    }
    return false;
}
```

## -53-连续最大子序和_简单


```java
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
public int maxSubArray(int[] nums) {
    if (nums == null || nums.length == 0) {
        return 0;
    }
    int[] dp = new int[nums.length];
    dp[0] = nums[0];
    int sum = dp[0];
    /**
     * 设sum[i]为以第i个元素结尾且和最大的连续子数组。假设对于元素i，
     * 所有以它前面的元素结尾的子数组的长度都已经求得，那么以第i个元素结尾且和最大的连续子数组实际上，
     * 要么是以第i-1个元素结尾且和最大的连续子数组加上这个元素，要么是只包含第i个元素，即sum[i]= max(sum[i-1] + a[i], a[i])。
     */
    for (int i = 1; i < nums.length; i++) {
        dp[i] = Math.max(dp[i - 1] + nums[i], nums[i]);
        sum = Math.max(sum, dp[i]);
    }
    return sum;
}
```

## -NC144-不连续最大子序列和_中等

```java
// 就是一个打家劫舍的问题, 相邻的不能偷，求能够偷出的最大金额是多少。

```







## -152-乘积最大子序列_中等

```java
```



## -300-最长递增子序列的长度_中等


```java
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
public int lengthOfLIS(int[] nums) {
    if (nums.length==1) {
        return 1;
    }
    // dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。
    int[] dp = new int[nums.length];
    // 因为子序列最少也要包含自己，所以长度最小为 1
    Arrays.fill(dp, 1);
    int result=0;
    for (int i = 0; i < nums.length; i++) {
        for (int j = 0; j < i; j++) {
            if (nums[i] > nums[j]) {
                // 位置i的最长升序子序列等于j从0到i-1各个位置的最长升序子序列 + 1 的最大值
                dp[i] = Math.max(dp[i], dp[j]+1);
            }
        }
        if (dp[i] > result) {
            result = dp[i]; // 取长的子序列
        }
    }
    return result;
}
```
## -673-最长递增子序列的个数_中等
```java
找到最长递增子序列的个数。
输入: [1,3,5,4,7]
输出: 2
解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。
```

## -674-最长连续递增子序列的长度_简单


```java
输入：nums = [1,3,5,4,7]
输出：3
解释：最长连续递增序列是 [1,3,5], 长度为3。
尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 
public int findLengthOfLCIS(int[] nums) {
    if (nums.length==1) {
        return 1;
    }
    // dp[i] 表示以 nums[i] 这个数结尾的连续递增子序列的长度。
    int[] dp = new int[nums.length];
    // 因为子序列最少也要包含自己，所以长度最小为 1
    Arrays.fill(dp,1);
    int result = 0;
    for (int i = 0; i < nums.length - 1; i++) {
        if (nums[i + 1] > nums[i]) { // 连续记录
            dp[i + 1] = dp[i] + 1;
        }
        if (dp[i + 1] > result) {
            result = dp[i + 1];
        }
    }
    return result;
}
```
## -1143-最长公共子序列_中等

```java
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列
输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
// 动态规划
public static int maxLong(String str1, String str2) {
     if (str1 == null || str2 == null || str1.length() == 0 || str2.length() == 0) {
         return 0;
     }
     char[] str1Arr = str1.toCharArray();
     char[] str2Arr = str2.toCharArray();
     int maxLen = 0;
     ArrayList<Character> list = new ArrayList<>();
     int[][] dp = new int[str1.length() + 1][str2.length() + 1];
     for (int i = 1; i <= str1Arr.length; i++) {
         for (int j = 1; j <= str2Arr.length; j++) {
             if (str1Arr[i-1] == str2Arr[j-1]) {
                 dp[i][j] = dp[i - 1][j - 1] + 1;
             } else {
                 dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
             }
             if (dp[i][j] > maxLen) {
                 maxLen = dp[i][j];
                 list.add(str1Arr[i-1]);
             }
         }
     }
     System.out.println(list);
     return list.size();
     // return dp[str1.length()][str2.length()];
 }
```



## -516-最长回文子序列_中等
## -491-递增子序列_中等

## -523-连续的子数组和_中等

```java
给你一个整数数组 nums 和一个整数 k ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：
子数组大小 至少为 2 ，且
子数组元素总和为 k 的倍数。
如果存在，返回 true ；否则，返回 false 。
如果存在一个整数 n ，令整数 x 符合 x = n * k ，则称 x 是 k 的一个倍数。0 始终视为 k 的一个倍数。

  
```



## -718-最长重复子数组_中等

```java
给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度
输入：
A: [1,2,3,2,1]
B: [3,2,1,4,7]
输出：3
解释：
长度最长的公共子数组是 [3, 2, 1] 。


```

# 子串

> 子串是连续的

## -NC127-最长公共子串_中等

```java
输入："1AB2345CD","12345EF"
输出："2345"
public String longestCommonPrefix(String str1, String str2) {
     String result = "";
     int start = 0;
     int end = 1;
     while (end <= str2.length()) {
         String subStr = str2.substring(start, end);
         if (str1.contains(subStr)) {
             result = subStr;
         } else {
             start++;
         }
         end++;
     }
     return result;
 } 
```





## -3-最长无重复子串长度_中等

## -3-1-最长无重复子数组长度


```java
输入：[2,2,3,4,3]
返回值：3
说明：[2,3,4]是最长子数组  

输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

// 滑动窗口
public  int lengthOfLongestSubstring(String s) {
    char[] chars = s.toCharArray();
    HashSet<Character> set = new HashSet<>();
    int start = 0, end = 0, maxLen = 0;
    while (end < s.length()) {
        if (!set.contains(chars[end])) {
            set.add(chars[end]);
            end++;
            maxLen = Math.max(maxLen, set.size());
        } else {
            set.remove(chars[start]);
            start++;
        }
    }
    return maxLen;
}
```

## -30-串联所有单词的子串_困难

```java
给定一个字符串 s 和一些 长度相同 的单词 words 。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。
注意子串要与 words 中的单词完全匹配，中间不能有其他字符 ，但不需要考虑 words 中单词串联的顺序。

输入：s = "barfoothefoobarman", words = ["foo","bar"]
输出：[0,9]
解释：
从索引 0 和 9 开始的子串分别是 "barfoo" 和 "foobar" 。
输出的顺序不重要, [9,0] 也是有效答案。


```



# 股票相关- 动态规划

[https://mp.weixin.qq.com/s/169FdlShVT1_GhLWA8eJlA](https://mp.weixin.qq.com/s/169FdlShVT1_GhLWA8eJlA?fileGuid=p3cxcwXqc6QVkk6k)

https://mp.weixin.qq.com/s/ubDMTzaSVw3Ks0F9YIXFeg


## -121-买卖股票的最佳时机_简单


```
只允许买卖一次
输入: [7,1,5,3,6,4]
输出: 5
```


![](https://youpaiyun.zongqilive.cn/image/20210514095707.png#id=WUqnH&originHeight=583&originWidth=886&originalType=binary&status=done&style=none)


![](https://youpaiyun.zongqilive.cn/image/20210514095720.png#id=uY2OM&originHeight=672&originWidth=866&originalType=binary&status=done&style=none)


```java
public static int maxProfit(int[] prices) {
    if (prices.length == 0) {
        return 0;
    }
    int[][] dp = new int[prices.length][2];
    //边界状态
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i]);
    }
    return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);
}
```


## -122-买卖股票的最佳时机II_简单


```java
无限次交易
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

public static int maxProfit(int[] prices) {
    if (prices.length == 0) {
        return 0;
    }
    int[][] dp = new int[prices.length][2];
    //边界状态
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
    }
    return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);
}
```


## -309-最佳买卖股票时机含冷冻期_中等


```java
设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

输入: [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
public int maxProfit(int[] prices) {
    if (prices == null || prices.length <= 1) return 0;
    
    int[][] dp = new int[prices.length][2];
    dp[0][0] = 0;
    dp[0][1] = -prices[0];
    // 注意第二天的初始条件
    dp[1][0] = Math.max(0, -prices[0] + prices[1]);
    dp[1][1] = Math.max(-prices[0], -prices[1]);
    for (int i = 2; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 2][0] - prices[i]);
    }
  return Math.max(dp[prices.length - 1][0], dp[prices.length - 1][1]);
}
```


## -123-买卖股票的最佳时机III_困难- 过

```java
// 只能交易2次
//扩展: 交易 k 次

// 交易k次 
public int help(int k, int[] prices) {
  if (prices == null || prices.length == 0) {
    return 0;
  }

  // dp[天数][卖出的次数][当前是否持股]=>dp[i][k][j]
  int[][][] dp = new int[prices.length][k + 1][2];
  dp[0][0][0] = 0; // 无股票无交易
  dp[0][0][1] = -prices[0]; // 买股票

  // 注意这个初始值, 需要每天都初始0次交易的情况
  for (int i = 0; i <= k; i++) {
    dp[0][i][0] = 0;
    dp[0][i][1] = -prices[0];
  }

  // 开始交易
  for (int i = 1; i < prices.length; i++) {
    for (int j = 1; j <= k; j++) {
      // 今天卖出股票交易次数是今天的交易次数
      dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
      // 今天买入股票交易次数是上一天买入的股票
      dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
    }
  }
  // 最终的交易最大值为卖股票的三种情形下的最大值
  return Math.max(dp[prices.length - 1][k][0],dp[prices.length - 1][k][1]);
}



//这个性能好点
public static int help(int k,int[] prices) {
  //如果交易次数小于1，返回0
  if (k < 1) {
    return 0;
  }
  //如果交易次数大于等于数组长度，此时就是第二种情况
  // if (k >= prices.length / 2) {
  //     return stockTrading2(prices);
  // }
  //每一天只有两个状态：买入和卖出
  //但是我们需要考虑次数k限制，所以我们可以增加一个维度描述第几次交易
  //dp[卖出的次数][当前是否持股]=dp[k][i],其中1={0，1}；0表示卖出,1表示持有
  //此时只有两种状态：
  //1.第i次不持有：此时情况为：本来不持有，这次不操作；要么第i次持有现在卖出
  //dp[i][0] = (dp[i][0],dp[i][1]+price)
  //2.第i次持有：此时情况为：本来持有，这次不操作；要么前一次不持有持有现在买入
  //dp[i][1] = (dp[i][1],dp[i-1][0]-price)

  //dp[卖出的次数][当前是否持股]=dp[k][i]
  int[][] dp = new int[k][2];
  //边界值：初始持有的最小值一定要小于prices的最小值
  for (int i = 0; i < k; i++) {
    dp[i][1] = Integer.MIN_VALUE;
  }
  for (int price : prices) {
    //注意要重设第一次交易的初始值，否则存在某一天多次交易问题
    //第一次不持有：要么之前就不持有，此时不操作；要么之前持有，现在第一次卖出入
    dp[0][0] = Math.max(dp[0][0], dp[0][1] + price);
    //第一次持有: 要么之前就是第一次持有，此时不操作；要么之前不持有，现在第一次买入
    dp[0][1] = Math.max(dp[0][1], -price);
    for (int i = 1; i < k; i++) {
      dp[i][0] = Math.max(dp[i][0], dp[i][1] + price);
      dp[i][1] = Math.max(dp[i][1], dp[i - 1][0] - price);
    }
  }
  return Math.max(dp[k - 1][0], dp[k - 1][1]);
}
```




## -200-岛屿数量_中等


给你一个由`'1'`（陆地）和`'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。


输入：grid = [


["1","1","1","1","0"],


["1","1","0","1","0"],


["1","1","0","0","0"],


["0","0","0","0","0"]


]


输出：1


```java
// 像扫雷游戏, 点中1,  周围的全变 0
public int numIslands(char[][] grid) {
    int count = 0;
    // if (grid == null || grid.length == 0) return count;
    int colLen = grid.length;// 行
    int rowLen = grid[0].length; // 列
    for (int col = 0; col < colLen; col++) {
        for (int row = 0; row < rowLen; row++) {
            if (grid[col][row] == '1') {
                count++;
                help(grid, col, row, colLen, rowLen);
            }
        }
    }
    return count;
}

private void help(char[][] grid, int col, int row, int colLen, int rowLen) {
    if (col < 0 || col >= colLen 
        || row < 0 || row >= rowLen 
        || grid[col][row] == '0') return;

    grid[col][row] = '0';
    dfs(grid, col - 1, colLen, row, rowLen); // 上
    dfs(grid, col + 1, colLen, row, rowLen);// 下
    dfs(grid, col, colLen, row - 1, rowLen);// 左
    dfs(grid, col, colLen, row + 1, rowLen);// 右
}
```


# 链表相关


## 方法总结


1. 快慢指针

快慢指针, 慢指针走1步, 快指针走2步


2. 虚拟节点

做链表题经常会产生困惑：


什么时候用创建一个dummy node，什么时候不用创建？


一般来说，如果head可能发生变化，就创建一个dummy，然后


虚拟节点套路


虚拟节点, 必跟着一个 current 指向


ListNode dummyNode = new ListNode(-1);


dummyNode.next = head

ListNode currentNode = dummyNode;

## -203-移除链表的指定元素_简单

```java
给你一个链表的头节点 head 和一个整数 val ，请你删除链表中所有满足 Node.val == val 的节点，并返回 新的头节点 。
public ListNode removeElements(ListNode head, int val) {
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;
    ListNode cur = dummyNode;
    while (cur.next != null) {
        if (cur.next.val == val) {
            cur.next = cur.next.next;
        }else {
            cur = cur.next;
        }
    }
    return dummyNode.next;
}
```




## (NC4)-141-判断环形链表_简单


HashSet 和 快慢指针


```java
// 快慢指针
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow next;
        fast = fast.next.next;
        if (slow == fast) {
            return true;
        }
    }
    return false;
}
```


问题扩展:


## 求出环的长度


```java
快慢指针相遇后继续移动，直到第二次相遇。两次相遇间的移动次数即为环的长度。
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) 
        return false
    ListNode slow = head
    ListNode fast = head
   
    while (fast != null && fast.next != null) 
        slow = slow next
        fast = fast.next.next
        if (slow == fast) {
           int count = 1;
          slow = slow.next();
          while(slow != fast) {
            slow = slow.next();
            count++;
          }
          return count;
        }
        return 0;
}
```


## **链表中倒数第k个节点**


![](https://youpaiyun.zongqilive.cn/image/20210514095914.png#id=xAYwg&originHeight=340&originWidth=561&originalType=binary&status=done&style=none)


```java
设置快和慢两个指针，初始化时快指针比慢指针 先移动k次，
然后两个指针每次都走一步，当快指针到达终点时，慢指针正好处在倒数第k的位置
public static int kthToLast(ListNode head, int k) {
    ListNode fast = head;
    ListNode slow = head;
    for (int i = 0; i < k; i++) {
        fast = fast.next;
    }
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    return slow.val;
}
```


## -19-删除链表的倒数第 N 个结点_中等


```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummy = new ListNode(0);
    dummy.next = head;
    
    ListNode fast = dummy;
    ListNode slow = dummy;
    for (int i = 0; i <= n; i++) {
        fast = fast.next;
    }
    while (fast != null) {
        fast = fast.next;
        slow = slow.next;
    }
    // 删除
    slow.next = slow.next.next;
    return dummy.next;
}
```

## -NC25-删除有序链表中重复的元素

## -876-链表的中间结点_简单


求链表的中间节点，如果链表节点数为奇数，返回中间节点；如果链表节点数为偶数，返回中间两个节点的任意一个。


```java
可以定义两个指针，同时从链表头节点出发，一个指针一次走一步，一个指针一次走两步。当走的快的指针走到链表的末尾时，走的慢的指针正好在链表的中间。
public ListNode middleNode(ListNode head) {
    ListNode slow = head, fast = head
    while (fast != null && fast.next != null) {
        slow = slow.next
        fast = fast.next.next
    }
    return slow;
}
```


## -142-链表中环的入口节点_中等


```java
第一步是确定该链表有没有环, 否存在环，若有找到一快一慢的两个指针相遇的节点
public ListNode detectCycle(ListNode head){
        ListNode slow=head;
        ListNode fast=head;
        while(fast!=null&&fast.nest!=null){
            fast=fast.next.next
            slow=slow.next;
            if(fast==slow){               //利用快慢指针找相遇点
                ListNode tmp=head; //设置以相同速度的新指针从起始位置出发
                while(slow2!=slow){      //未相遇循环。
                    slow=slow.next;
                    tmp=tmp.next;
                }
                return slow;
            }
        }
        return null;
    }
```


## -206-反转链表_简单 - 双指针


```java
* 输入: 1->2->3->4->5->NULL
* 输出: 5->4->3->2->1->NULL
* 进阶:
* 你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
public static ListNode reverseListV2(ListNode head) {
    public ListNode ReverseList(ListNode head) {
        ListNode newHead = null;
        while(head!=null) {
            ListNode tmp = head.next;
            head.next = newHead;
            newHead = head;
            head = tmp;
        }
        return newHead;
    }
}
```


## -92-反转链表II_中等(局部翻转)


```
反转从位置 m 到 n 的链表。请使用一趟扫描完成反转
输入: 1->2->3->4->5->NULL, m = 2, n = 4
输出: 1->4->3->2->5->NULL
```


![](https://youpaiyun.zongqilive.cn/image/20210514095936.png#id=ZantM&originHeight=343&originWidth=766&originalType=binary&status=done&style=none)


```java
public ListNode reverseBetween(ListNode head, int m, int n) {
    ListNode dummyNode = new ListNode(-1);
    dummyNode.next = head;
    ListNode currentNode = dummyNode;
    
    ListNode m_node = head;
    ListNode n_node = head;
    // 找到m 和 n 节点,
    // 移动m-1 和 n-1步 找到
    for (int i = 0; i< m - 1; i++) {
        m_node = m_node.next;
        // 移动current
        currentNode = currentNode.next;
    }
    for (int i =0; i < n - 1; i++) {
        n_node = n_node.next;
    }
    while (m_node != n_node) {
        currentNode.next = m_node.next;
        m_node.next=n_node.next;
        n_node.next=m_node;
        // m_node 往前移动
        m_node = currentNode.next;
    }
    return dummyNode.next;
}
```

## -25- K个一组翻转链表_困难

## -24-两两交换链表中的节点_中等(k=2)


```java
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
public ListNode reverseKGroup(ListNode head, int k) {
    // 先找到一段
    ListNode tail = head;
    for (int i = 0; i < k; i++) {
        if (tail == null) {
            // 剩下的不够 一组
            return head;
        }
        tail = tail.next;
    }
    
    ListNode newHead = reverse206(head, tail);
    head.next = reverseKGroup(tail, k);
    return newHead;
}
private ListNode reverse206(ListNode head, ListNode tail) {
    ListNode newHead = null;
    // 注意是 tail
    while (head != tail) {
        ListNode tmp = head.next;
        head.next = newHead;
        newHead = head;
        head = tmp;
    }
    return newHead;
}

// -24-两两交换链表节点
[1,2,3,4,5]
[2,1,4,3,5]
/**
 * 递归实现方式
 *
 * 从链表的头节点 head 开始递归。
 * 每次递归都负责交换一对节点。由 firstNode 和 secondNode表示要交换的两个节点。
 * 下一次递归则是传递的是下一对需要交换的节点。若链表中还有节点，则继续递归。
 * 交换了两个节点以后，返回 secondNode，因为它是交换后的新头。
 * 在所有节点交换完成以后，我们返回交换后的头，实际上是原始链表的第二个节点。
 */
public ListNode swapPairs(ListNode head) {
    if ((head == null) || (head.next == null)) {
        return head;
    }
    ListNode firstNode = head;
    ListNode secondNode = head.next;
    firstNode.next  = swapPairs(secondNode.next);
    secondNode.next = firstNode;
    return secondNode;
}
```


## -21-合并两个有序链表_简单


```java
public ListNode mergeTwoLists(ListNode linked1, ListNode linked2) {
    //下面4行是空判断
    if (linked1 == null) {
        return linked2;
    }
    if (linked2 == null) {
        return linked1;
    }
    // dummy: 傀儡, 假
    ListNode dummy = new ListNode(0);
    // cur指针是复制的dummy指针，dummy始终都在头节点处，而cur相当于不断地在穿针引线串联增加节点
    ListNode curr = dummy;
    while (linked1 != null && linked2 != null) {
        //比较一下，哪个小就把哪个放到新的链表中
        if (linked1.val <= linked2.val) {
            curr.next = linked1;
            linked1 = linked1.next;
        } else {
            curr.next = linked2;
            linked2 = linked2.next;
        }
        curr = curr.next;
    }
    //然后把那个不为空的链表挂到新的链表中
    curr.next = linked1 == null ? linked2 : linked1;
    // dummy是虚拟节点，需要返回的是它后面的链表，也就是dummy.next
    return dummy.next;
}
```

## -23-合并K个升序链表_困难

```java
给你一个链表数组，每个链表都已经按升序排列。
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6

public ListNode mergeKLists(ListNode[] lists) {
    PriorityQueue<ListNode> queue = new PriorityQueue<>((o1, o2) -> {
        return o1.val - o2.val;
    });
  // 节点入队
    for (ListNode head : lists) {
        while (head != null) {
            queue.add(head);
            head = head.next;
        }
    }
    ListNode dummy = new ListNode(0);
    ListNode cur = dummy;
    while (!queue.isEmpty()) {
        cur.next = queue.poll();
        cur = cur.next;
    }
    // 纯粹为了过, 最后设置一下
    cur.next = null;
    return dummy.next;
}
```

## -369-单链表末尾加1_中等


```java
输入: [1,2,3]
输出: [1,2,4]

public ListNode plusOne(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode cur = head;
  	Stack<Integer> stack  = new Stack<>();
    while (cur!=null) {
        stack.push(cur.val);
        cur = cur.next;
    }
    int carry = 1;
    while (!stack.isEmpty()) {
        Integer tmp = stack.pop();
        int sum = tmp.val + carry;
        carry = sum / 10;
        tmp.val = sum % 10;
        if (carry == 0) {
            return head;
        }
    }
    if (carry != 0) {
        ListNode new_head = new ListNode(carry);
        new_head.next = head;
        return new_head;
    }else {
        return head;
    }
}
```


## -2-链表相加_中等


![](https://youpaiyun.zongqilive.cn/image/20210607094239.png)


表示两个非负的整数。它们每位数字都是按照`逆序`的方式存储的


```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
  ListNode dummyNode = new ListNode(-1);
  ListNode currentNode = dummyNode;
  //进位
  int carry = 0;
  while (l1 != null || l2 != null || carry > 0) {
    int n1 = (l1 == null) ? 0 : l1.val;
    int n2 = (l2 == null) ? 0 : l2.val;
    int tmp = n1 + n2 + carry;
    int val = tmp % 10;
    carry = tmp / 10;
    ListNode node = new ListNode(val);
    currentNode.next = node;
    currentNode = node;

    l1 = (l1 != null) ? l1.next : null;
    l2 = (l2 != null) ? l2.next : null;
  }
  return dummyNode.next;
}
```


## -445-链表相加II_中等


输入链表非逆序存储


```java
数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 8 -> 0 -> 7
public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    ListNode dummy = new ListNode(-1);
    ListNode cur = dummy;

    Stack<Integer> s1 = new Stack<>();
    Stack<Integer> s2 = new Stack<>();
    // 利用栈
    while (l1 != null) {
        s1.push(l1.val);
        l1 = l1.next;
    }
    while (l2 != null) {
        s2.push(l2.val);
        l2 = l2.next;
    }

    //ListNode newHead = null;
    int carry = 0;
    while (!s1.isEmpty() || !s2.isEmpty() || carry > 0) {
        int n1 = s1.isEmpty() ? 0 : s1.pop();
        int n2 = s2.isEmpty() ? 0 : s2.pop();
        int sum = n1 + n2 + carry;
        carry = sum / 10;
        int val = sum % 10;
      
        ListNode node = new ListNode(val);  
        ListNode tmp = cur.next;
        cur.next = node;
        node.next = tmp;
      
        // 头插法
        // node.next = newHead;
        // newHead = node;
    }
    // return newHead;
    return dummy.next;
}
```
## -369-单链表加1_中等


```java
输入: [1,2,3]
输出: [1,2,4]
Stack<Integer> stack  = new Stack<>();
public ListNode plusOne(ListNode head) {
    if (head == null) {
        return head;
    }
    ListNode cur = head;
    while (cur!=null) {
        stack.push(cur.val);
        cur = cur.next;
    }
    int carry = 1;
    while (!stack.isEmpty()) {
        Integer tmp = stack.pop();
        int sum = tmp.val + carry;
        carry = sum / 10;
        tmp.val = sum % 10;
        if (carry == 0) {
            return head;
        }
    }
    if (carry != 0) {
        ListNode new_head = new ListNode(carry);
        new_head.next = head;
        return new_head;
    }else {
        return head;
    }
}
```


## -2-链表相加_中等

![](https://youpaiyun.zongqilive.cn/image/20210530104250.png)

表示两个非负的整数。它们每位数字都是按照逆序的方式存储的


```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummyNode = new ListNode(-1);
        ListNode currentNode = dummyNode;
        //进位
        int carry = 0;
        while (l1 != null && l2 != null) {
            int tmp = l1.val + l2.val + carry;
            int val = tmp % 10;
            carry = tmp / 10;
            ListNode node = new ListNode(val);
            currentNode.next = node;
            currentNode = node;
            l1 = l1.next;
            l2 = l2.next;
        }
        if (l1 != null) {
            while (l1 != null) {
                int tmp = l1.val + carry;
                int val = tmp % 10;
                carry = tmp / 10;
                ListNode node = new ListNode(val);
                currentNode.next = node;
                currentNode = node;
                l1 = l1.next;
            }
        }
        if (l2 != null) {
            while (l2 != null) {
                int tmp = l2.val + carry;
                int val = tmp % 10;
                carry = tmp / 10;
                ListNode node = new ListNode(val);
                currentNode.next = node;
                currentNode = node;
                l2 = l2.next;
            }
        }
        if (carry != 0) {
            ListNode node = new ListNode(carry);
            currentNode.next = node;
            currentNode = node;
        }
        return dummyNode.next;
    }
```


## -445-链表相加II_中等

非逆序
```java
数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
输出：7 -> 8 -> 0 -> 7
public static ListNode addTwoNumbers(ListNode l1, ListNode l2) {
    Stack<Integer> s1 = new Stack<>();
    Stack<Integer> s2 = new Stack<>();
    // 利用栈
    while (l1 != null) {
        s1.push(l1.val);
        l1 = l1.next;
    }
    while (l2 != null) {
        s2.push(l2.val);
        l2 = l2.next;
    }
    ListNode newHead = null;
    int carry = 0;
    while (!s1.isEmpty() || !s2.isEmpty() || carry > 0) {
        int n1 = s1.isEmpty() ? 0 : s1.pop();
        int n2 = s2.isEmpty() ? 0 : s2.pop();
        int sum = n1 + n2 + carry;
        carry = sum / 10;
        int val = sum % 10;
        ListNode node = new ListNode(val);
        // 头插法
        node.next = newHead;
        newHead = node;
    }
    return newHead;
}
```



## -160-相交链表_简单


![](https://youpaiyun.zongqilive.cn/image/20210516093202.png#id=j1I5B&originHeight=556&originWidth=818&originalType=binary&status=done&style=none)
```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    ListNode A = headA;
    ListNode B = headB;
    while (A != B) {
        A = (A == null) ? headB : A.next;
        B = (B == null) ? headA : B.next;
    }
    // 确保不能为 null
    return A == null ? null : A;
}
```


## -234-回文链表_中等
请判断一个链表是否为回文链表。
**示例 1:**
**输入:** 1->2
**输出:** false
**输入:** 1->2->2->1
**输出:** true

```java
// 利用栈, 空间是O(n)
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    Stack<Integer> stack = new Stack<>();
    ListNode cur = head;
  // 入栈
    while (cur != null) {
        stack.push(cur.val);
        cur = cur.next;
    }
  // 出栈比较
    while (head != null) {
        Integer val = stack.pop();
        if (!val.equals(head.val)) {
            return false;
        }
        head = head.next;
    }
    return true;
}
```
方法2: 空间O(1)
![](https://youpaiyun.zongqilive.cn/image/20210516160907.png#id=jntHo&originHeight=490&originWidth=977&originalType=binary&status=done&style=none)
```java
public boolean isPalindrome(ListNode head) {
    if (head == null || head.next == null) {
        return true;
    }
    ListNode fast = head;
    ListNode slow = head;
    ListNode pre = head;
    // 快慢指针 找链表中间节点
    while (fast != null && fast.next != null) {
        fast = fast.next.next;
        pre = slow;
        slow = slow.next;
    }

    ListNode newHead = null;
    if (fast == null) {
        // 偶数个 Node节点
        // 切断联系
        pre.next = null;
        // 反转链表
        newHead = reverse(slow);
    } else {
        // 奇数个 Node节点
        // 切断联系
        pre.next = null;
        ListNode next = slow.next;
        slow.next = null;
        // 反转链表
        newHead = reverse(next);
    }
    // 挨个比较
    while (head != null) {
        if (head.val != newHead.val) {
            return false;
        }
        head = head.next;
        newHead = newHead.next;
    }
    return true;
}
```

## -89-分隔链表_中等

```java

```

## -728-分隔链表_中等



## -148-快排链表_中等

https://leetcode-cn.com/problems/sort-list/solution/gui-bing-pai-xu-he-kuai-su-pai-xu-by-a380922457/

# 二叉树相关


## 二叉树的遍历 前, 中, 后, 层


![](https://youpaiyun.zongqilive.cn/image/20210514100002.png#id=Yotxx&originHeight=375&originWidth=420&originalType=binary&status=done&style=none)


### 前序遍历1  2  4  5  7  8  3  6


```java
递归写法
  LinkedList<Integer> list = new LinkedList<>();
// 递归
public List<Integer> preorderTraversal(TreeNode root) {
  if (root != null) {
    list.add(root.val);
    preorderTraversal(root.left);
    preorderTraversal(root.right);
  }
}
// 非递归先序遍历
public static void preorderTraversal(TreeNode root) {
  // 用来暂存节点的栈
  Stack<TreeNode> stack = new Stack<TreeNode>();
  // 新建一个游标节点为根节点
  TreeNode node = root;
  // 当遍历到最后一个节点的时候，无论它的左右子树都为空，并且栈也为空
  // 所以，只要不同时满足这两点，都需要进入循环
  while (node!= null || !stack.isEmpty()) {
    // 若当前考查节点非空，则输出该节点的值
    // 由考查顺序得知，需要一直往左走
    if (node != null){
      list.add(node.val);
      // 为了之后能找到该节点的右子树，暂存该节点
      stack.push(node);
      node = node.left;
    }else{
      node = stack.pop();
      node = node.right
    }  
  }
}
```


### 中序遍历4  2  7  5  8  1  3  6


```java
LinkedList<Integer> list = new LinkedList<>();
/**
 *递归写法
 */
public List<Integer> inorderTraversal(TreeNode root) {
    if (root != null) {
        inorderTraversal(root.left);
        list.add(root.val);
        inorderTraversal(root.right);
    }
    return list;
}
// 非递归中序
public List<Integer> inorderTraversal(TreeNode root) {
  Stack<TreeNode> stack = new Stack<TreeNode>();
    TreeNode node = root;
    while (node!=null || !stack.isEmpty()) {
        if (node!=null) {
            stack.push(node);
            node = node.left;
        }else {
             node = stack.pop();
             list.add(node.val);
             node = node.right;
        }
    }
    return list;
}
```


### 后序遍历4  7  8  5  2  6  3  1


```java
LinkedList<Integer> list = new LinkedList<>();
// 递归
public List<Integer> preorderTraversal(TreeNode root) {
    if (root != null) {
        preorderTraversal(root.left);
        preorderTraversal(root.right);
        list.add(root.val);
    }
    return list;
}
// todo 注意使用 LinkedList
public static List<Integer> postorderTraversal(TreeNode root) {
    Stack<TreeNode> stack = new Stack<>();
    TreeNode node = root;
    while (node != null || !stack.isEmpty()) {
        if (node != null) {
           // 头插
            list.addFirst(node.val)
            stack.add(node);
            // 这次是 右节点
            node = node.right;
        } else {
            node = stack.pop();
            node = node.left;
        }
    }
    return list;
}
第二种写法
// 非递归后序遍历
public static void postorderTraversal(TreeNode root) {
    Stack<TreeNode> treeNodeStack = new Stack<TreeNode>();
    TreeNode node = root;
    TreeNode lastVisit = root;
    while (node != null || !treeNodeStack.isEmpty()) {
        while (node != null) {
            treeNodeStack.push(node);
            node = node.left;
        }
        //查看当前栈顶元素
        node = treeNodeStack.peek();
        //如果其右子树也为空，或者右子树已经访问
        //则可以直接输出当前节点的值
        if (node.right == null || node.right == lastVisit) {
            System.out.print(node.val + " ");
            treeNodeStack.pop();
            lastVisit = node;
            node = null;
        } else {
            //否则，继续遍历右子树
            node = node.right;
        }
    }
}
```


### 层序遍历1  2  3  4  5  6  7  8


```java
Queue<TreeNode> queue = new LinkedList<TreeNode>();
ArrayList<Integer> list = new ArrayList<>();
//层序遍历 利用队列
public List<Integer> levelOrderV(TreeNode root) {
    if (root == null) {
        return list;
    }
    // 加入队列
    queue.add(root);
    while (!queue.isEmpty()) {
        // zz 出队首的元素
        TreeNode node = queue.poll();
        list.add(node.val);
        //zz 将元素的 左右孩子入队
        if (node.left !=null) {
            queue.add(node.left);
        }
        if (node.right != null) {
            queue.add(node.right);
        }
    }
    return list;
}
```


## -199-二叉树的右视图_中等
```java
给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
输入: [1,2,3,null,5,null,4]
输出: [1, 3, 4]
解释:

   1            <---
 /   \
2     3         <---
 \     \
  5     4       <---

 // 利用层序遍历
private List<Integer> res = new LinkedList<>();
public List<Integer> rightSideView(TreeNode root) {
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
          // 每层中的最后一个元素
            if (i==size-1) {
                res.add(node.val);
            }
        }
    }
    return res;
}
```




## _-103-_蛇型(锯齿形)遍历_中等
![](https://youpaiyun.zongqilive.cn/image/20210530104320.png)
层序遍历的变形

```java
// 一维数组
List<Integer> res2 = new LinkedList<>();
LinkedList<Integer> tmp = new LinkedList<>();
public void zigzagLevelOrder(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    // 遍历标志
    boolean flag = true;
    queue.add(root);
    while (!queue.isEmpty()) {
        LinkedList<Integer> tmp = new LinkedList<>();
        int size = queue.size();
        for (int i = 0; i < size; i++) {
            TreeNode node = queue.poll();
            if (flag == true) {
                tmp.add(node.val);
            } else {
                // 头插法
                tmp.addFirst(node.val);
            }
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        res2.addAll(tmp);
        // 下一层,变换标志
        flag = !flag;
    }
}

// 二维数组
static List<List<Integer>> res = new LinkedList<>();
public List<List<Integer>> zigzagLevelOrder2(TreeNode root) {
    if (root == null) {
        return res;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    //遍历标记
    boolean flag = true;
    while (!queue.isEmpty()) {
        LinkedList<Integer> tmp = new LinkedList<>();
        for (int i = 0; i < queue.size(); i++) {
            TreeNode node = queue.poll();
            if (flag == 0) {
                tmp.add(node.val);
            } else {
                // 头插法
                tmp.addFirst(node.val);
            }
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        res.add(tmp);
        // 下一层,变换标志
        flag = !flag;
    }
    return res;
}
```


## 概念: 二叉树类型区分
### 满二叉

1. 除了叶结点外每一个结点都有左右子叶节点
1. 叶子结点都处在最底层的二叉树



### 完全二叉树
在满叉树的基础上，我在最后一层==从右往左==删去若干节点，得到的都是完全二叉树
所以说，满二叉树一定是完全二叉树，但是完全二叉树不一定是满二叉树


### 平衡二叉树
树的左右子树的高度差不超过1的数
是二叉搜索树的一个进化体


## -98-验证二叉搜索树_中等


```java
// 利用 中序遍历 有序
public boolean isValidBST(TreeNode root) {
    if (root == null) {
        return true;
    }
    Stack<TreeNode> stack = new Stack<>();
    TreeNode node = root;
    TreeNode pre = null;
    while (node != null || !stack.isEmpty()) {
        if (node != null) {
            stack.push(node);
            node = node.left;
        }else {
            node = stack.pop();
            if (pre != null && node.val <= pre.val)
                return false;
            //保存前一个访问的结点
            pre = node;
            node = node.right;
        }
    }
    return true;
}
```


## -110-验证平衡二叉树_简单


```java
// 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
public boolean isBalanced(TreeNode root) {
    if (root == null) {
        return true;
    }
    if (root.left == null && root.right == null) {
        return true;
    }
    return isBalanced(root.left) && isBalanced(root.right)
            && Math.abs(depth(root.left) - depth(root.right)) <= 1;
}

private int depth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    return Math.max(depth(root.left), depth(root.right)) + 1;
}
```
## -101-对称二叉树_简单




```java
  1
   / \
  2   2
 / \ / \
3  4 4  3
 
 
public boolean isSymmetric(TreeNode root) {
    //第一次传root让下面顺便进行空判断
    return check(root.left, root.right);
}
public boolean check(TreeNode a, TreeNode b) {
    //都为空则没有子树，两个根相等就是对称
    if (a == null && b == null) {
        return true;
    }
    //不满足上面条件，则是一个有子树一个没有那么不对称
    if (a != null && b != null && a.val == b.val) {
        //三个条件结合
        return check(a.left, b.right) && check(a.right, b.left);
    }else{
        return false;   
    }    
}
```


## -226-翻转二叉树_简单


根节点的左右子节点 互换


```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) {
        return null;
    }
    TreeNode temp = root.left;
    root.left = root.right;
    root.right = temp;
    invertTree(root.left);
    invertTree(root.right);
    return root;
}
```

## -236-二叉树的最近公共祖先_中等


![](https://youpaiyun.zongqilive.cn/image/20210514100117.png#id=zozci&originHeight=190&originWidth=200&originalType=binary&status=done&style=none)


```java
/**
 * 两个节点p,q分为两种情况：
 *
 * p和q在相同子树中
 * p和q在不同子树中
 * 从根节点遍历，递归向左右子树查询节点信息
 * 递归终止条件：如果当前节点为空或等于p或q，则返回当前节点
 *
 * 递归遍历左右子树，如果左右子树查到节点都不为空，则表明p和q分别在左右子树中，因此，当前节点即为最近公共祖先；
 * 如果左右子树其中一个不为空，则返回非空节点。
 */
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        return root;
    }
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if (left != null && right != null) {
            return root;
    }
    return left == null ? right : left;
}
```

## -235-二叉搜索树的最近公共祖先_简单


![](https://youpaiyun.zongqilive.cn/image/20210514100048.png#id=l2Vny&originHeight=190&originWidth=200&originalType=binary&status=done&style=none)


输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8


输出: 6


解释: 节点 2 和节点 8 的最近公共祖先是 6。


```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) {
        return root;
    }
    if (p.val < root.val && q.val < root.val) {
        // p, q 都在左子树
        return lowestCommonAncestor(root.left, p,q);
    }
    if (p.val > root.val && q.val > root.val) {
        // p, q 都在右子树
        return lowestCommonAncestor(root.right, p, q);
    }
        return root;
}
```

## -230-二叉搜索树中第K小或第K大的元素_中等


第K小: 中序遍历 数组升序递增,  第k个元素就是


第K大: 中序遍历的逆序 数组升序递减,  第k个元素就是


```java
/**
 * 利用二叉搜索树的 中序遍历, 得带有序数组
 * 利用栈的方式 以加快速度，因为这样可以不用遍历整个树，可以在找到答案后停止。
 */
// 第 k 小的元素
public int kthSmallest(TreeNode root, int k) {
    Stack<TreeNode> stack = new Stack<>();
    ArrayList<Integer> list = new ArrayList<>();
    TreeNode node = root;
    while (node!=null || !stack.isEmpty()) {
        if (node != null) {
            stack.add(node);
            node = node.left;
        }else {
            node = stack.pop();
            //zz 优化 提升效率, 不必遍历全树
            if (--k ==0) {
                return node.val;
            }
            list.add(node.val);
            node = node.right;
        }
    }
    return 0;
}
// 第k大的元素 , 中序遍历的逆序(左右节点交换)
public int kthLargest(TreeNode root, int k) {
        Stack<TreeNode> stack = new Stack<>();
        ArrayList<Integer> list = new ArrayList<>();
        TreeNode node = root;
        while (node!=null || !stack.isEmpty()) {
            if (node != null) {
                stack.add(node);
                // 逆序
                node = node.right;
            }else {
                node = stack.pop();
                //zz 优化 提升效率, 不必遍历全树
                if (--k ==0) {
                    return node.val;
                }
                list.add(node.val);
                node = node.left;
            }
        }
        return 0;
    }
```


## -257-二叉树的所有路径_简单
解释: 所有根节点到叶子节点的路径为: 1->2->5, 1->3


```java
List<Integer> path = new ArrayList<>();
List<List<Integer>> result = new ArrayList<>();
// 递归 + 回溯
public void dfs(TreeNode root) {
    // 递归退出条件
    if (root == null) {
        return;
    }
    path.add(root.val);
    if (root.left == null && root.right==null) {
        result.add(new ArrayList<>(path));
    }else {
        dfs(root.left);
        dfs(root.right);
    }
    // 回溯
    path.remove(path.size()-1);
}
```


## -112-路径总和_简单


判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。


给定如下二叉树，以及 目标和sum = 22，


5


/ \


4   8


/   / \


11  13  4


/  \      \


7    2      1


返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。


```java
public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) {
        return false;                // 遍历到null节点
    }
    sum = sum - root.val;
    if (root.left == null && root.right == null && sum ==0) {
        return true;        // 如果满足这个就返回true
    }
    // 左子树 或者 右子树存在 就行
    return hasPathSum(root.left, sum) || hasPathSum(root.right, sum); 
}
```


## -113-路径总和II中等


找到所有从根节点到叶子节点路径总和等于给定目标和的路径


```java
private List<Integer> path = new ArrayList<>();
private List<List<Integer>> result = new ArrayList<>();
public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
    help(root, targetSum);
    return result;
}
// 递归 + 回溯
public void help(TreeNode root, int sum) {
    if (root == null) {
        return;                // 遍历到null节点
    }
    path.add(root.val);
    sum -= root.val;
    if (root.left == null && root.right == null && sum == 0) { // 遍历到叶子节点
        result.add(new ArrayList<>(path));
        // 不能进行return
        // return;
    }else {
        help(root.left,sum);
        help(root.right,sum);
    }
    // 回溯
    path.remove(path.size()-1);
}
```


## -437-路径总和III_中等


```java
找出路径和等于给定数值的路径总数。
路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）
int count = 0;
public int pathSum(TreeNode root, int sum) {
    if(root == null) {
        return 0;
    }
    Sum(root,sum);
    pathSum(root.left,sum);
    pathSum(root.right,sum);
    return count;
}
public void Sum(TreeNode root, int sum){
    if(root == null) {
        return;
    }
    sum -= root.val;
    if(sum == 0){
        count++;
    }
    // 不能用 else
    Sum(root.left,sum);
    Sum(root.right,sum);
}
```


## -104-二叉树的最大深度_简单 或 最小深度


```java
// 最大深度
public int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null) {
        return 1 + maxDepth(root.right);
    }
    if (root.right == null) {
        return 1 + maxDepth(root.left);
    }
  // 递归
    int leftHeight= maxDepth(root.left);
    int rightHeight= maxDepth(root.right);
    return 1 + Math.max(leftHeight, rightHeight);
}
// 最小 深度
public int minDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    if (root.left == null) {
        return 1 + minDepth(root.right);
    }
    if (root.right == null) {
        return 1 + minDepth(root.left);
    }
    // 递归
    int leftHeight = minDepth(root.left);
    int rightHeight = minDepth(root.right);
    return 1+ Math.min(leftHeight, rightHeight);
}
```


## -617-合并二叉树_简单


```java
给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点
思路分析：
1.我们可以对这两棵树同时进行前序遍历，并将对应的节点进行合并。
2. 在遍历时，如果两棵树的当前节点均不为空，我们就将它们的值进行相加，并对它们的左孩子和右孩子进行递归合并；如果其中有一棵树为空，那么我们返回另一颗树作为结果；如果两棵树均为空，此时返回任意一棵树均可（因为都是空）
public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if(t1 == null){
            return t2;
        }
        if(t2 == null){
            return t1;
        }
        TreeNode result = new TreeNode(t1.val + t2.val);
        result.left = mergeTrees(t1.left,t2.left);
        result.right = mergeTrees(t1.right,t2.right);
        return result;
    }
```

## -114-二叉树展开为链表_中等

![](https://youpaiyun.zongqilive.cn/image/20210622095834.png)


```java
public void flatten(TreeNode root) {
    help(root);
}
public TreeNode help(TreeNode root) {
    // root = null的情况
    if (root == null) {
        return root;
    }
    TreeNode left = root.left;
    TreeNode right = root.right;
        
    if (left != null) {
        //注意需要将左子树置null
        root.left = null;
        // 链表链接左子树
        root.right = left;
        // 获得链接的尾节点
        root = help(left);
    }
    if (right != null) {
        // 链表链接右子树
        root.right = right;
        // 获得链接的尾节点
        root = help(right);
    }
    // 返回链接的尾节点
    return root;
}
```
## -116-填充每个节点的下一个右侧节点指针_中等
![](https://youpaiyun.zongqilive.cn/image/20210530104429.png)
```java
public Node connect(Node root) {
    if (root == null) {
        return null;
    }
    if (root.left == null && root.right == null) {
        return root;
    }
    root.left.next = root.right;
    if (root.next != null) {
        root.right.next = root.next.left;
    }
    connect(root.left);
    connect(root.right);
    return root;
}
```
## 938. 二叉搜索树的范围和


# 全排列-回溯(递归回溯)


[https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hui-su-suan-fa-dfs-suan-fa/hui-su-suan-fa-xiang-jie-xiu-ding-ban](https://labuladong.gitbook.io/algo/suan-fa-si-wei-xi-lie/hui-su-suan-fa-dfs-suan-fa/hui-su-suan-fa-xiang-jie-xiu-ding-ban?fileGuid=p3cxcwXqc6QVkk6k)


```
解决一个回溯问题，实际上就是一个决策树的遍历过程
只需要思考 3 个问题：
1、路径：也就是已经做出的选择。
2、选择列表：也就是你当前可以做的选择。
3、结束条件：也就是到达决策树底层，无法再做选择的条件。
```


回溯算法的框架：


```
result = []
def backtrack(路径, 选择列表):
    if 满足结束条件:
        result.add(路径)
        return
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
其核心就是 for 循环里面的递归，在递归调用之前「做选择」，在递归调用之后「撤销选择」
```


## -46-全排列_简单
```java
没有重复的数
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

private List res = new ArrayList<List<Integer>>();
public List<List<Integer>> permute(int[] nums) {
    // 路径, 选择列表
    m(new ArrayList<>(), nums, new boolean[nums.length]);
    return res;
}
/**
 *
 * @param track 路径
 * @param nums 选择列表 nums 中不存在于 track 的那些元素
 *             结束条件：nums 中的元素全都在 track 中出现
 */
private void m(int[] nums, List<Integer> path,  boolean[] visited) {
    // 触发结束条件
    if (path.size() == nums.length) {
        res.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (visited[i] == true) {
            continue;
        }
        // 做选择
        visited[i] = true;
        path.add(nums[i]);
        // 递归 进入下一层决策树
        m(path nums, visited);
        // 取消选择
        path.remove(path.size()-1);
        visited[i] = false;
    }
}
```


## -47-全排列II_中等
包含重复数字
```java
private List result = new ArrayList<List<Integer>>();
public List<List<Integer>> permuteUnique(int[] nums) {
    if (nums == null || nums.length == 0) {
        return result;
    }
    //注意 有重复数字 先排序
    Arrays.sort(nums);
    helper(nums, new ArrayList<>(), new boolean[nums.length]);
    return result;
}
public void helper(int[] nums, List<Integer> path, boolean[] visited) {
    if (path.size() == nums.length) {
        result.add(new ArrayList<>(path));
        return;
    }
    for (int i = 0; i < nums.length; i++) {
        if (visited[i]) {
            continue;
        }
        if (i - 1 >= 0 && nums[i] == nums[i - 1] && visited[i - 1]) {
            continue;
        }
        path.add(nums[i]);
        visited[i] = true;
        helper(nums, path, visited);
        path.remove(path.size() - 1);
        visited[i] = false;
    }
}
```


## -78-子集_中等-dfs+回溯


不重复的数组


```java
List<List<Integer>> result = new LinkedList<>();
public List<List<Integer>> subsets(int[] nums) {
  // 空集是所有集合的子集
    result.add(new LinkedList<>());
    helper(nums, new LinkedList<>(), 0);
    return result;
}
public void helper(int[] arr,List<Integer> path, int start) {
    if (start >= arr.length) {
        return;
    }
    for (int i = start; i < arr.length; i++) {
        path.add(arr[i]);
        result.add(new LinkedList<>(path));
        helper(arr, path,i+1);
        path.remove(path.size()-1);
    }
}
```


## -90-子集II_中等


数组存在重复


```java
List<List<Integer>> result = new LinkedList<>();
public List<List<Integer>> subsetsWithDup(int[] nums) {
    result.add(new LinkedList<>());
    // 注意先排序
    Arrays.sort(nums);
    helper(nums, new LinkedList<>(), 0);
    return result;
}
public void helper(int[] arr, List<Integer> path, int start) {
    if (start >= arr.length) {
        return;
    }
    for (int i = start; i < arr.length; i++) {
        if (i > start && arr[i] == arr[i - 1]) {
            // 去掉重复
            continue;
        }
        path.add(arr[i]);
        result.add(new LinkedList<>(path));
        helper(arr, path, i + 1);
        path.remove(path.size() - 1);
    }
}
```


## -39-组合求和_中等


原数组无重复元素, 元素可以使用多次


```java
输入：candidates = [2,3,6,7], target = 7,
所求解集为：
[
  [7],
  [2,2,3]
]
private List result = new LinkedList<List<Integer>>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
      // 排序  
      Arrays.sort(candidates);
        help(candidates, new LinkedList<>(), target, 0);
        return result;
    }
private void help(int[] arr, List<Integer> path, int target,int start) {
        if (target == 0) {
            result.add(new LinkedList<>(path));
            return;
        }
        for (int i = start; i < arr.length; i++) {
            if (arr[i] > target) {
                return;
              // continue; 排序了就return, 否则 continue
            }
            path.add(arr[i]);
            // 注意target , 可以使用重复的
            help(arr, path, target-arr[i], i);
            path.remove(path.size()-1);
        }
    }
```


## -40-组合求和II_中等


原数组有重复元素, 元素可以使用1次


```java
private List result = new ArrayList<List<Integer>>();
public List<List<Integer>> combinationSum2(int[] candidates, int target) {
  // 有重复元素, 先排序   
  Arrays.sort(candidates);
    help(candidates,  target, new LinkedList<>(),0);
    return result;
}
private void help(int[] arr,  int target, List<Integer> path, int start) {
    if (target == 0) {
        result.add(new LinkedList<>(path));
        return;
    }
    for (int i = start; i < arr.length; i++) {
        if (arr[i] > target) {
            return;
        }
        if (i-start>0 && arr[i-1]==arr[i]){
            continue;
        }
        path.add(arr[i]);
        help(arr,target-arr[i], path, i+1);
        path.remove(path.size()-1);
    }
}
```


## 寻找全排列的下一个数


在一个整数所包含数字的全部组合中, 找到一个大于且仅大于 原数的新整数


如:


输入 12345, 则返回 12354


12354, 则返回 12435


12435, 则返回 12453

# 数组

## -66-数组加1_简单

```java
输入：digits = [1,2,3]
输出：[1,2,4]
解释：输入数组表示数字 123。

```






## -4-寻找两个正序数组的中位数_困难


```
给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。

输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```


## -215-数组中的第K个最大(小)元素_中等


```java
## 思路1: 
升如果是升序，那就是返回nums[n-k],
如果是降序，那就是返回nums[k-1]
 使用快速排序 O(nlogn)
 public int findKthLargest(int[] nums, int k) {
    Arrays.sort(nums);
    return nums[nums.length - k];
}
## 思路3: 借助 快排 partition 分区来帮助找到第K大元素
如果 pivot 点刚好是第K大元素，那么它的左边一定有 K-1 个不小于它的元素，它的下标应该是len-k
// 快排 + 二分查找
public static int findKthLargestV2(int[] nums, int k) {
    int left = 0;
    int right = nums.length-1;
    int target = nums.length- k; // 第K大
    // int target = k - 1; // 第K小
    while (left <= right) {
        int pivot= partition(nums, left, right);
        if (pivot == target) {
            return nums[pivot];
        }else if (pivot< target ) {
            left = pivot + 1;
        }else {
            right = pivot - 1;
        }
    }
}
private int partition(int[] a, int left, int right) {
    int mid = left;
    while (left < right) {
        while (left < right && a[right] >= a[mid]) {
            right--;
        }
        while (left < right && a[left] <= a[mid]) {
            left++;
        }
        if (left < right) {
            swap(a, left, right);
        }
    }
    swap(a, left, mid);
    return left;
}
```

## 最小的k个数_中等

```java
输入：arr = [3,2,1], k = 2
输出：[1,2] 或者 [2,1]
//方法1: 利用快排 找到第K个数, 退出 
public static int[] smallestK(int[] arr, int k) {
    if (k >= arr.length) {
        return arr;
    }
    int left = 0;
    int high = arr.length - 1;
    int targrt = k - 1;
    while (left < high) {
        int pos = partition(arr, left, high);
        if (pos == targrt) {
          // 找到第k个数退出
            break;
        } else if (pos < targrt) {
            left = pos + 1;
        } else {
            high = pos - 1;
        }
    }
  
    int[] result = new int[k];
    for (int i = 0; i < k; i++) {
        result[i] = arr[i];
    }
    return result;
}


//方法二: 要遍历全部数组
public static PriorityQueue<Integer> smallestKV2(int[] arr, int k) {
    // 最大堆, 堆顶是最大值
    PriorityQueue<Integer> queue = new PriorityQueue<>((o1, o2) -> {
        return o2 - o1;
    });
    for (int num : arr) {
        if (queue.size() < k){
            queue.add(num);
        } else {
          if (queue.peek() > num) {
              queue.poll();
              queue.add(num);
          }
        }
    }
    return queue;
}
```



## -88-合并两个有序数组_简单


初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。


你可以假设 nums1 有足够的空间


请将数组 nums2合并到数组 nums1中，变成一个有序的数组


```java
// nums1 和 nums2 的元素数量分别为 m 和 n
public void merge(int[] nums1, int m, int[] nums2, int n) {
    // 新数组 最大下标
    int k = m + n - 1;
    int i1 = m - 1; // mum1 最大下标
    int i2 = n - 1; // mum2 最大下标
    while (i1 >= 0 && i2 >= 0) {
        if (nums1[i1] > nums2[i2]) {
            //大的先放
            nums1[k] = nums1[i1];
            i1--;
        } else {
            nums1[k] = nums2[i2];
            i2--;
        }
        k--;
    }
    // 处理剩下的 num2 数组
    while (i2 >= 0) {
        nums1[k] = nums2[i2];
        k--;
        i2--;
    }
}
```


## -283-移动零_简单


```java
public static void moveZeroes(int[] nums) {
    int len = nums.length;
    int w = 0;
    for (int i = 0; i < len; i++) {
        if (nums[i] != 0) {
            // 不等于 0 的数字, 往前移动
            nums[w] = nums[i];
            w++;
        }
    }
    if (w < len) {
        // 对剩下的 填充 0
        for (int i = w; i < len; i++) {
            nums[i] = 0;
        }
    }
}
```


## -26-删除有序数组中的重复项_简单


```java
给定数组 nums = [1,1,2], 
函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 
public int removeDuplicates(int[] nums) {
    // 快慢指针
    int slow = 0, fast = 1;
    while (fast < nums.length) {
        if (nums[slow] != nums[fast]) {
         ​   slow++
            ​nums[slow] = nums[fast]
            ​fast+
        } else {
            fast++;
        }
    }
    return slow + 1;
}
```


## -27-移除数组中指定重复元素_简单


```java
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案
// 双指针
public int removeElement(int[] nums, int val) {
    int fast = 0, slow = 0;
    while (fast < nums.length) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast];
            fast++;
            slow++;
        }else {
            fast++;
        }
    }
    return slow;
}
```


## -287-寻找数组中重复数_中等


```java
nums 只有 一个重复的整数 ，找出 这个重复的数 。
输入：nums = [1,3,4,2,2]
输出：2
public int findDuplicate(int[] nums) {
    /**
     快慢指针思想,游走必然是成环的, 环的入口就是重复的元素,
     即按照寻找链表环入口的思路来做
     **/
    int fast = 0, slow = 0;
    while (true) {
        fast = nums[nums[fast]];
        slow = nums[slow];
        if (slow == fast) {
           int slow2 = 0;
            while (nums[slow] != nums[slow2]) {
                slow2= nums[slow2];
                slow = nums[slow];
            }
            return nums[slow];
        }
    }
}
```


## -347-数组中前K个高频元素_中等


```java
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
public int[] topKFrequent(int[] nums, int k) {
    Map<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    // 求前 k 大，用小堆，求前 k 小，用大堆
    PriorityQueue<Map.Entry<Integer, Integer>> heap =
    new PriorityQueue<>((v1, v2) -> v2.getValue() - v1.getValue());
    
    heap.addAll(map.entrySet());
    int[] res = new int[k];
    while (!heap.isEmpty() && k > 0) {
        res[--k] = heap.poll().getKey();
    }
    return res;
}
```


_最最小的K个数


## -189-旋转数组_简单


```java
/**
 * todo 反转法
 * <p>
 * 当我们旋转k次后，k%n个尾部元素会移动到数组前头，剩余的元素被往后移动
 * <p>
 * 首先将所有数组反转，接着再把前k个元素反转，最后再反转后n-k个元素
 * 假设nums=[1 , 2 , 3 , 4 , 5 , 6 , 7] n = 7且 k =3
 * 1. 反转所有元素：[7 , 6 , 5, 4 , 3 , 2 , 1]
 * 2. 反转前k个元素：[5 , 6 , 7 , 4 , 3, 2 , 1]
 * 3. 反转后n-k个元素：[5 , 6 , 7 , 1 , 2 , 3 , 4]此时即为结果
 * <p>
 * 时间复杂度: O(n), 反转了3次, 相当于3*O(n), 还是O(n)
 */
 
public void rotateV2(int[] nums, int k) {
    k = k % nums.length;
    reverse(nums, 0, nums.length - 1);
    reverse(nums, 0, k - 1);
    reverse(nums, k, nums.length - 1);
}
// 反转数组
private void reverse(int[] nums, int start, int end) {
    // 注意调条件
    while (start < end) {
        int tmp = nums[start];
        nums[start] = nums[end];
        nums[end] = tmp;
        start++;
        end--;
    }
}
```
## -35-搜索插入位置_简单
```java
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。
如果目标值不存在于数组中，返回它将会被按顺序插入的位置

// 二分查找
public int searchInsert(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    
    return left;
}
```
## -33-搜索旋转排序数组_中等



## -219-存在重复元素II_简单

```java
判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值 至多为 k
输入: nums = [1,2,3,1], k = 3
输出: true
// 有点像 滑动窗口
public boolean containsNearbyDuplicateV2(int[] nums, int k) {
    int len = nums.length;
    if (len<2) {
        return false;
    }
    HashSet<Integer> set = new HashSet<>();
    for (int i = 0; i < len; i++) {
        if (set.add(nums[i])) {
            if (set.size() == k+1) {
                set.remove(nums[i-k]);
            }
        }else {
            return true;
        }
    }
    return false;
}
```

## -191-二进制中1的个数_简单

```java
如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影响。


举个例子：一个二进制数1100，从右边数起第三位是处于最右边的一个1。减去1后，第三位变成0，它后面的两位0变成了1，而前面的1保持不变，因此得到的结果是1011.我们发现减1的结果是把最右边的一个1开始的所有位都取反了。这个时候如果我们再把原来的整数和减去1之后的结果做与运算，从原来整数最右边一个1那一位开始所有位都会变成0。如1100&1011=1000.也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二进制有多少个1，就可以进行多少次这样的操作。

public int hammingWeight(int n) {
  int count = 0;
  while(n!= 0){
    count++;
     // n & （-n）得到的结果相当于只保留n对应二进制的最低位的1，其余高位的1全部转换成0
    // n & n -1 得到的结果相当于把n对应二进制中最低位的1转换成0 
    n = n & (n - 1);
  }
  return count;
}
```

## -485-二进制中连续1的个数_简单

```java
输入：[1,1,0,1,1,1]
输出：3
public int findMaxConsecutiveOnes(int[] nums) {
  int max = 0;
  int tmp = 0;
  for (int item : nums) {
    if (item == 1) {
      tmp += 1;
    } else {
      max = Math.max(max, tmp);
      tmp = 0;
    }

  }
  return Math.max(max, tmp);
}
```





## 串烧 33 81 153 154 

```java
假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
注意: 数组元素不重复

// 看这个吧
public int search(int[] nums, int target) {
    int left = 0;
    int right = nums.length - 1;
    while (left <= right) {
        int mid = left+(right - left)/ 2;
        if (nums[mid] == target) {
            return mid;
        }
        if (nums[0] <= nums[mid]) {
            // 左半段有序
            if (target >= nums[0] && target < nums[mid]) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        } else {
            // 右半段有序
            // target 大于重点并且小于最末元素则在
            if (target <= nums[nums.length - 1] && target > nums[mid]) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
    }
    return -1;
}

// 方法二
public int search(int[] nums, int target) {
    int cutOff = -1;
    // 找到 旋转点
    for (int i = 0; i < nums.length - 1; i++) {
        if (nums[i] > nums[i + 1]) {
            cutOff = i;
            break;
        }
    }
    int left = binarySearch(nums, 0, cutOff, target);
    int right = binarySearch(nums, cutOff + 1, nums.length - 1, target);
    return left == -1 ? right : left;
}
```


# 滑动窗口

滑动窗口老猛了, 子串问题全靠它

左右指针滑窗口, 一前一后齐头进

```java
// 标准模板
int left = 0, right = 0;
while (right < s.size()) {
  // 增大窗口
  window.add(s[right]);
  right++;

  // 什么条件下缩小窗口
  while (window needs shrink) {
    // 缩小窗口
    window.remove(s[left]);
    left++;
  }
}
```



## -76-最小覆盖子串_困难

```java
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。
输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"

  

```





## -239-滑动窗口最大值_困难
```java
一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。
  输入：nums = [1,3,-1,-3,5,3,6,7], k = 3
  输出：[3,3,5,5,6,7]
  解释：
  滑动窗口的位置                最大值
  ---------------               -----
  [1  3  -1] -3  5  3  6  7       3
  1 [3  -1  -3] 5  3  6  7       3
  1  3 [-1  -3  5] 3  6  7       5
  1  3  -1 [-3  5  3] 6  7       5
  1  3  -1  -3 [5  3  6] 7       6
  1  3  -1  -3  5 [3  6  7]      7

//方式1 暴力解法. 超时
public int[] maxSlidingWindowV2(int[] nums, int k) {
  //边界条件判断
  if (nums == null || nums.length == 0) {
    return new int[0];
  }
  int res[] = new int[nums.length - k + 1];
  for (int i = 0; i < res.length; i++) {
    int max = nums[i];
    //在每个窗口内找到最大值
    for (int j = 1; j < k; j++) {
      max = Math.max(max, nums[i + j]);
    }
    res[i] = max;
  }
  return res;
}

/**
  * 双端队列 (单调队列)
  * 在双端队列中，要始终保证队头是队列中最大的值或最小值
  * todo 需要总结 https://mp.weixin.qq.com/s/vM6ha7Wwp_EkfRMfLg1dZQ
  * https://mp.weixin.qq.com/s/kyae7wCXII4P_ZytE-OF0A
  */
 public static int[] maxSlidingWindow(int[] nums, int k) {
     // 注意这里存储的是元素在数组中的下标，不是元素的值
     LinkedList<Integer> deque = new LinkedList<>();
     int[] res = new int[nums.length - k + 1];
     int index = 0;
     for (int i = 0; i < nums.length; i++) {
         // 在尾部添加元素，并保证左边元素都比尾部大
         // getLast - 列表尾部的最后一个元素
         while (!deque.isEmpty() && nums[deque.getLast()] < nums[i]) {
             // removeLast() 移除尾部元素
             deque.removeLast();
         }
         // 下标加入队尾, 存的是下标
         deque.addLast(i);

         // 保证窗口k大小, 删除头部元素,
         //getFirst() 获取头部元素
         if (!deque.isEmpty() && deque.getFirst() + k == i) {
             deque.removeFirst();
         }
         // 当窗口的长度大于等于k个的时候才开始计算（注意这里的i是从0开始的）
         if (i >= k - 1) {
             // 队头元素是队列中最大的，把队列头部的元素加入到数组中
             res[index++] = nums[deque.getFirst()];
         }
     }
     return res;
 }
```

## -480-滑动窗口中位数_困难

## -424-替换后的最长重复字符_中等

```java
```





## -1004-最大连续1的个数 III_中等

```java
给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 
返回仅包含 1 的最长（连续）子数组的长度。
输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
输出：6
解释： 
[1,1,1,0,0,1,1,1,1,1,1]
粗体数字从 0 翻转到 1，最长的子数组长度为 6。
  
/**
  * 思路：
  * 维护一个数字zeroCount，记录窗口内0的个数。
  * 维护两个指针，左指针、右指针，右指针每次走一步，如果当前指针数字是0，zeroCount加1；
  * 如果zeroCount大于 K，就是补0次数用完，左指针也要走一步；同时，如果左指针走之前的数是0的话，zeroCount还要减回1。
  * 最后的right - leht（也就是窗口的长度）就是最大的个数。因为这个窗口只会记录最大的1长度，不会缩小。
  */
 public int longestOnes(int[] nums, int k) {
     int start = 0, end = 0;
     int zeroCount = 0; // 窗口中0的个数
     int maxWindow = 0;//窗口的最大值
     int len = nums.length;
     while (end < len) {
         if (nums[end] == 0) {
             zeroCount++;
         }
         end++;
         //如果窗口中0的个数超过了K，要缩小窗口的大小，直到0的个数不大于K
         while (zeroCount > k) {
             if (nums[start] == 0) {
                 zeroCount--;
             }
             start++;
         }
         //记录最大的窗口
         maxWindow = Math.max(maxWindow, end - start + 1);
     }
     // 窗口值则是最长1的个数
     return maxWindow;
 }
```





# 字符串

## -14-最长公共前缀_简单


```java
输入：strs = ["flower","flow","flight"]
输出："fl"
示例 2：
public String longestCommonPrefix(String[] strs) {
    if (strs.length==0) {
        return "";
    }
    String prefix = strs[0];
    for (int i = 1; i < strs.length; i++) {
        // 前缀 出现开头的位置, 期望是 0
        while (strs[i].indexOf(prefix) != 0) {
            prefix = prefix.substring(0,prefix.length()-1);
        }
    }
    return prefix;
}
```


## -387-字符串中的第一个唯一字符_简单
```java
给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。
s = "leetcode"
返回 0
s = "loveleetcode"
返回 2
   
 // map计数 map(char, num)
public int firstUniqChar(String s) {
  HashMap<Character, Integer> map = new HashMap<>();
  char[] chars = s.toCharArray();
  for (int i = 0; i < chars.length; i++) {
    map.put(chars[i], map.getOrDefault(chars[i], 0) + 1);
  }
  for (int i = 0; i < chars.length; i++) {
    if (map.get(chars[i]) == 1) {
      return i;
    }
  }
  return -1;
}
```

## -424-替换后的最长重复字符_中等





# 回文相关

回文: 就是正着读 和 倒着读 是一样的
## -647-回文子串的个数_中等
```java
输入："abc"
输出：3
解释：三个回文子串: "a", "b", "c"
 
int num = 0;
public int countSubstrings(String s) {
    char[] chars = s.toCharArray();
    int len = chars.length;
    for (int i = 0; i < len; i++) {
        help(chars, len, i, i); //回文串长度为奇数
        help(chars, len, i, i + 1); //回文串长度为偶数
    }
    return num;
}

public void help(char[] chars, int len, int start, int end) {
    while (start >= 0 && end < len) {
        if (chars[start] == chars[end]) {
            start--;
            end++;
            num++;
        } else {
            break;
        }
    }
}
```


## -5-最长回文子串_中等 --中心扩散法
```java
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。

private int[] range = new int[2];
public String longestPalindrome(String s) {
    char[] chars = s.toCharArray();
    int len = chars.length;
    if (len == 0 || len == 1) {
        return s;
    }
    for (int i = 0; i < len; i++) {
        help(chars, len, i, i);
        help(chars, len, i , i+1);
    }
    return s.substring(range[0], range[1]); // 范围是左闭右开 [range[0],range[1])
}

private void help(char[] chars, int len, int start, int end) {
    while (start >= 0 && end < len) {
        if (chars[start] == chars[end]) {
            start--;
            end++;
        } else {
            break;
        }
    }
    // 注意 start + 1
    if ((end - (start + 1)) > (range[1] - range[0])) {
        range[0] = start + 1;
        range[1] = end;
    }
}
```
## -9-验证回文数_简单
```java
回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。

public boolean isPalindrome(int x) {
    String s = String.valueOf(x);
    char[] chars = s.toCharArray();
    return checkHuiWen(chars, 0, chars.length - 1);
}

// 检查是否是回文 通用方法. 双指针法
private static boolean checkHuiWen(char[] chars, int start, int end) {
    while (start < end) {
        if (chars[start] == chars[end]) {
            start++;
            end--;
        } else {
            return false;
        }
    }
    return true;
}
```
## -125-验证回文串_简单
```java
// 验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。
public boolean isPalindrome(String s) {
    char[] chars = s.toCharArray();
    //只保存字母数字
    StringBuilder tmp = new StringBuilder(1024);
    for (int i = 0; i < chars.length; i++) {
        if (Character.isLetterOrDigit(chars[i])) {
            tmp.append(Character.toLowerCase(chars[i])) ;
        }
    }
    char[] chars1 = tmp.toString().toCharArray();
    return checkHuiWen(chars1, 0, chars1.length - 1);
}
```
## -680-验证回文串II_简单
```java
给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。
输入: "abca"
输出: True
解释: 你可以删除c字符。

public boolean validPalindrome(String s) {
    char[] chars = s.toCharArray();

    int start = 0;
    int end = s.length() - 1;
    while (start < end) {
        if (chars[start] == chars[end]) {
            start++;
            end--;
        } else {
            return checkHuiWen(chars, start, end - 1) 
            || checkHuiWen(chars, start + 1, end);
        }
    }
    return true;
}
```

# 栈

## -20-有效的括号_简单


```java
public static boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    char[] chars = s.toCharArray();
    for (char i : chars) {
        if (i == '(') {
            // zz 压入 相反的
            stack.add(')');
        } else if (i == '{') {
            // zz 压入 相反的
            stack.add('}');
        } else if (i == '[') {
            // zz 压入 相反的
            stack.add(']');
        } else {
            if (stack.isEmpty()) {
                return false;
            }
            if (i != stack.pop()) {
                return false;
            }
        }
    }
    return stack.isEmpty();
}
```

## -22-括号生成



## -232-用栈实现队列_简单

```java
```




# 贪心算法


## -55-跳跃游戏_中等


```java
输入：nums = [2,3,1,1,4]
输出：true
解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
public boolean canJump(int[] nums) {
    int max_i = 0;
    for (int i = 0; i < nums.length; i++) {
        //如果跳不到位置i，直接返回false
        if (i > max_i) {
            return false;
        }
        max_i = Math.max(max_i, i + nums[i]);
    }
    return max_i >= nums.length - 1;
}
```


## -45-跳跃游戏II_困难-过

# 数学

## -509-斐波那契数_简单

```java
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
输入：4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
// 动态规划
public int fib(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
  // 状态容器
    int[] dp = new int[n + 1];
  // 初始化
    dp[0] = 0;
    dp[1] = 1;
  // 状态方程
    for (int i = 2; i < n + 1; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}  

// 二次优化, 节省空间
public int fib(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    int pre1 = 0;
    int pre2 = 1;
    int sum = 0;
    for (int i = 2; i < n + 1; i++) {
        sum = pre1 + pre2;
        pre1 = pre2;
        pre2 = sum;
    }
    return sum;
}

// 递归写法, 存在重复计算的问题
public int fib(int n) {
    if (n == 0 || n == 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}



```






## -136-只出现一次的数字_简单


```java
异或 规律
// 相同的数异或为0: n ^ n => 0
// 任何数于0异或为任何数 0 ^ n => n
// 交换律: a ^ b ^ c <=> a ^ c ^ b
/**
 * 异或
 * <p>
 * var a = [2,3,2,4,4]
 * 2 ^ 3 ^ 2 ^ 4 ^ 4等价于 2 ^ 2 ^ 4 ^ 4 ^ 3 => 0 ^ 0 ^3 => 3
 */
给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
 
public int singleNumber(int[] nums) {
    int result = 0;
    for (int i = 0; i < nums.length; i++) {
        result ^= nums[i];
    }
    return result;
}
```


## -260-只出现一次的数字 III_中等


```java
给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
将3和5 , 分别分到2个不同的数组中
public int[] singleNumber(int[] nums) {
    int[] res = new int[2];
    int tmp = 0;
    for (int i = 0; i < nums.length; i++) {
        tmp ^= nums[i];
    }
    // 保留最右边的 1
    int group = tmp & (-tmp);
    for (int y : nums) {
        if ((group & y) == 0) {
            // 分组为 0的组, 组内异或
            res[0] ^= y;
        } else {
            // 分组为 1的组, 组内异或
            res[1] ^= y;
        }
    }
    return res;
}
```


## -137-只出现一次的数字II_中等


```java
一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素
输入: [2,2,3,2]
输出: 3
public int singleNumber(int[] arr) {
    // 先排序
    Arrays.sort(arr);
    int n = arr.length;
    // 在开头
    if (n==1 || arr[0] != arr[1]) {
        // [1]
        // [1,2,2,2]
        return arr[0];
    }
    // 在结尾
    if (arr[n-2] != arr[n-1]) {
        // [2,2,2,3]
        return arr[n-1];
    }
    // 在中间, 从1开始, 到 n-1
    for (int i = 1; i < n - 1; i++) {
        if (arr[i] != arr[i-1] && arr[i] != arr[i+1]) {
            return arr[i];
        }
    }
    return 0;
}
```


## -633-平方数之和_中等


```java
给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a^2 + b^2 = c 。
输入：c = 5
输出：true
解释：1 * 1 + 2 * 2 = 5
```


```java
/**
 * 利用双指针判断是否存在,
 * 设a为最小值, b为最大值, b可取c的平方, 因为c=a^2+b^2
 *
 */
public boolean judgeSquareSum(int c) {
    int a = 0;
    int b = (int) Math.sqrt(c);
    while (a <= b) {
        int sum = a * a + b * b;
        if (sum == c) {
            return true;
        } else if (sum > c){
            b--;
        }else {
            a++;
        }
    }
    return false;
```

## -69-x的平方根_简单

```java
// 二分查找
public int mySqrt(int x) {
  int left = 0;
  int right = x;
  int res = 0;
  while (left <= right) {
    int mid = (left + right ) / 2;
    // 防止溢出
    if ((long)mid * mid <= x) {
      res = mid;
      left = mid + 1;
    } else {
      right = mid -1;
    }
  }
  return res;
}
```







## 判断一个正整数 是不是2的整数次幂


![](https://youpaiyun.zongqilive.cn/image/20210514100245.png#id=kvnll&originHeight=563&originWidth=916&originalType=binary&status=done&style=none)


```
public function boolean isPowerOf2(int num) {
  return (num&(num-1)) == 0;
}
```


## 删除K个数字后的最小值


给出一个整数, 从该整数中去掉K个数组嘛要求剩下的数字形成的新整数尽可能小, 如何选取被去掉的数字?


```
思路:
把原整数的所有数字, 从左往右 进行比较, 若该位的数字 大于 其右边的数字, 那么删除该数字
```


例如:


541270936 , 删除1位


数字5大于其右边的4, 所以删除5


41270936, 删除1位


数字4大于其右边的1, 所以删除4


1270936, 删除1位


数字7大于其右边的0, 所以删除7


```java
public static String func(String num, int k) {
    String newNum = num;
    for (int i = 0; i < k; i++) {
        boolean hasCut = false;
        for (int j = 0; j < newNum.length()-1; j++) {
            if (newNum.charAt(j) > newNum.charAt(j+1)) {
                newNum = newNum.substring(0,j)+newNum.substring(j+1, newNum.length());
                hasCut=true;
                break;
            }
        }
        // 没有找到, 则删除最后一个数字
        if (!hasCut) {
            newNum = newNum.substring(0,newNum.length()-1);
        }
    }
    return newNum;
}
```


## _大整数相加 (重点)


```java
private static String jisuan(String str1, String str2) {
    int maxLen = Math.max(str1.length(), str2.length());
    // 构建数组
    // 数组长度 = 较大数的位数 + 1
    int[] arr1 = new int[maxLen + 1];
    int[] arr2 = new int[maxLen + 1];
    //zz 将数字放入数组中, 倒序存放,
    for (int i = 0; i < str1.length(); i++) {
        // ASC码48就是'0'，也就是说'0'的值是48，而后依次是'1'到'9'。 这样正好是char型减去48就是它对应的int值。
        arr1[i] = str1.charAt(str1.length() - 1 - i) - '0';
    }
    for (int i = 0; i < str2.length(); i++) {
        // ASC码48就是'0'，也就是说'0'的值是48，而后依次是'1'到'9'。 这样正好是char型减去48就是它对应的int值。
        arr2[i] = str2.charAt(str2.length() - 1 - i) - '0';
    }
    // 进位
    int carry = 0;
    int[] res = new int[maxLen + 1];
    for (int i = 0; i < res.length; i++) {
        int tmp = arr1[i] + arr2[i] + carry;
        res[i] = tmp % 10;
        carry = tmp / 10;
    }
    //zz 再次倒序 输出, 去掉首部0
    StringBuilder str = new StringBuilder();
    for (int i = res.length - 1; i >= 0; i--) {
          str.append(res[i]);
    }
    return str.toString();
}
```


## -1-两数之和 简单


```java
给定 nums = [2, 7, 11, 15], target = 9
因为 nums[0] + nums[1] = 2 + 7 = 9
所以返回 [0, 1]
数组中同一个元素不能使用两遍
public int[] twoSum(int[] nums, int target) {
    // Map (值, 下标)
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        map.put(nums[i], i);
    }
    for (int i = 0; i < nums.length; i++) {
        int diffValue = target - nums[i];
        if (map.containsKey(diffValue) && map.get(diffValue) != i) {
            return new int[]{i, map.get(diffValue)};
        }
    }
    throw new IllegalArgumentException("No two sum solution");
}
```

## -167-两数之和II_简单

```java
升序的有序数组
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
public int[] twoSum(int[] arr, int target) {
    int left = 0;
    int right = arr.length - 1;
    while (left < right) {
        if (arr[left] + arr[right] == target) {
            return new int[]{left, right};
        } else if (arr[left] + arr[right] < target) {
            left++;
        } else {
            right--;
        }
    }
    //因为题目告诉我们一定有解，所以这里随便返回了
    return new int[] { -1, -1 };
}
```

## -15-三数之和_中等

## -18-四数之和_中等


```java
给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

List<List<Integer>> result = new ArrayList<>();
public static List<List<Integer>> threeSum(int[] nums) {
    if (nums == null || nums.length < 3) {
        return result;
    }
    // 数组排序, 为了去重
    Arrays.sort(nums);
    help(nums, new ArrayList<>(), 0, 0, 3);
    return result;
}

// 回溯, 运行超时
/**
 * @param arr    数组
 * @param target 目标和
 * @param start  从下标几开始
 * @param k      选出 多少个元素为一组
 */
public void help(int[] arr, List<Integer> path, int target, int start, int k) {
    if (target == 0 && path.size() == k) {
        result.add(new ArrayList<>(path));
        return;
    }
    for (int i = start; i < arr.length; i++) {
        if (i > start && arr[i] == arr[i - 1]) {
            continue;
        }
        if (arr[i] > target) {
            return;
        }
        path.add(arr[i]);
        helpV2(arr, path, target - arr[i], i + 1, k);
        path.remove(path.size() - 1);
    }
}

// 回溯不超时
/**
 * @param arr    数组
 * @param target 目标和
 * @param start  从下标几开始
 * @param k      选出 多少个元素求和
 */
public static void help(int[] arr, List<Integer> path, int target, int start, int k) {
    int len = arr.length;
    if (k > 2) {
        for (int i = start; i < len; i++) {
            if (i > start && arr[i] == arr[i - 1]) {
                continue;
            }
            if (arr[i] > target) {
                return;
            }
            path.add(arr[i]);
            help(arr, path, target - arr[i], i + 1, k - 1);
            path.remove(path.size() - 1);
        }
    } else if (k == 2) {
        // 两数求和 双指针, 是一种被迫的方式, 不然会超时
        int left = start, right = len - 1;
        while (left < right) {
            int tmp = arr[left] + arr[right];
            if (tmp < target) {
                // 去重
                do {
                    left++;
                } while (left < right && arr[left] == arr[left - 1]);
            } else if (tmp > target) {
                // 去重
                do {
                    right--;
                } while (left < right && arr[right] == arr[right + 1]);
            } else {
                path.add(arr[left]);
                path.add(arr[right]);
                result.add(new ArrayList<>(path));

                path.remove(path.size() - 1);
                path.remove(path.size() - 1);

                // 去重 , 往中间走
                while (left < right && arr[left] == arr[left + 1]) {
                    left++;
                }
                while (left < right && arr[right] == arr[right - 1]) {
                    right--;
                }

                left++;
                right--;
            }
        }
    }
}
```

## -16-最接近的三数之和_中等

`

# 设计

## -146-LRU缓存机制_中等

```java
public class LRUCache {
    class Node {
        int key;
        int value;
        Node prev;
        Node next;
        public Node() {
        }
        public Node(int _key, int _value) {
            key = _key;
            value = _value;
        }
    }
    private Map<Integer, Node> cache = new HashMap<Integer, Node>();
    private int size;
    private int capacity;
    private Node head, tail;
    
    public LRUCache(int capacity) {
        this.size = 0;
        this.capacity = capacity;
        // 使用伪头部和伪尾部节点
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.prev = head;
    }
    
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 如果 key 存在，先通过哈希表定位，再移到头部
        moveToHead(node);
        return node.value;
    }
    
    private void moveToHead(Node node) {
        removeNode(node);
        addToHead(node);
    }
    
    private void removeNode(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void addToHead(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node == null) {
            // 如果 key 不存在，创建一个新的节点
            Node newNode = new Node(key, value);
            // 添加进哈希表
            cache.put(key, newNode);
            // 添加至双向链表的头部
            addToHead(newNode);
            ++size;
            if (size > capacity) {
                // 如果超出容量，删除双向链表的尾部节点
                Node tail = removeTail();
                // 删除哈希表中对应的项
                cache.remove(tail.key);
                --size;
            }
        } else {
            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
            node.value = value;
            moveToHead(node);
        }
    }
    
    private Node removeTail() {
        Node res = tail.prev;
        removeNode(res);
        return res;
    }
}
```




## _-460-LFU缓存__困难


# 其他
## 实现两个线程交替输出奇偶数


```java
// 无需判断数字是否是奇偶数，两个线程通过等待唤醒机制，交替打印数字。 
private static int count = 0;
private static final Object lock = new Object();
public static void main(String[] args) {
    new Thread(new TurningRunner(), "偶线程").start();
    new Thread(new TurningRunner(), "奇线程").start();
}
static class TurningRunner implements Runnable {
    @Override
    public void run() {
        while (count < 100) {
            synchronized (lock) {
                //拿到锁就打印
                System.out.println(count++);
                lock.notify();
                if (count < 100) {
                    //如果任务还没结束，就让出当前的锁，并休眠
                    lock.wait();
                }
            }
        }
    }
}
```


## _生产者消费者模型


```java
public class Storage {
    // 仓库容量
    private final int MAX_SIZE = 10;
    // 仓库存储的载体
    private final LinkedList<Object> list = new LinkedList<>();
    
    public void produce() throws InterruptedException {
        synchronized (list) {
            while (MAX_SIZE == list.size()) {
                System.out.println("【生产者" + Thread.currentThread().getName() + "】仓库已满");
                list.wait();
            }
            list.add(new Object());
            System.out.println("【生产者" + Thread.currentThread().getName() + "】生产一个产品，现库存" + list.size());
            list.notifyAll();
        }
    }
    public void consume() throws InterruptedException {
        synchronized (list) {
            while (list.size() == 0) {
                System.out.println("【消费者" + Thread.currentThread().getName()
                        + "】仓库为空");
                list.wait();
            }
            list.remove();
            System.out.println("【消费者" + Thread.currentThread().getName() + "】消费一个产品，现库存" + list.size());
            list.notifyAll();
        }
    }
}
// 生产者
public class Producer implements Runnable {
    private Storage storage;
    public Producer(){}
    public Producer(Storage storage){
        this.storage = storage;
    }
    @Override
    @SneakyThrows
    public void run(){
        while(true){
            storage.produce();
        }
    }
}
// 消费者
public class Consumer implements Runnable {
    private Storage storage;
    public Consumer(){}
    public Consumer(Storage storage){
        this.storage = storage;
    }
    @Override
    @SneakyThrows
    public void run(){
        while(true){
            storage.consume();
        }
    }
}
// Main
public class Main {
    public static void main(String[] args) {
        Storage storage = new Storage();
        new Thread(new Producer(storage), "生产者线程").start();
        new Thread(new Consumer(storage), "消费者线程").start();
    }
}
```


## _顺序打印ABC


## 赛马问题


```
有一个赛场上共有25匹马，赛场有5个跑道，不使用计时器进行比赛（也就是每次比赛只能得到本次的比赛的顺序）
试问最少比多少场才能选出最快的三匹马？并给出分析过程！
1. 先跑5次：首先我们把25匹马分成5组（A、B、C、D、E），跑上五次，得到每组的第一名
2. 第6次跑：让这5个第一名跑上一次，得到其中的前三名。注意：这里就可以得到所有马中跑的最快的第一名A1了。并且，D1和E1所在的组可以直接淘汰。第二名和第三名一定不会在其中产生！
3. 第7次跑：因为我们已经跑出了第一名，所以A1不需要再参加比赛，同时，D1和E1所在的组已经淘汰。C1作为第三组的第一名，C组不会有跑的比C1快的。而B2有可能是比C1跑的快的第三名。同理，A2和A3也有可能是比B1和B2跑的快的。所以第7次比赛，我们让A2，A3，B1，B2，C1来一起完成。
```


跑5次, 回去 5个第一名


![](https://youpaiyun.zongqilive.cn/image/20210514100311.png#id=G0yGf&originHeight=547&originWidth=471&originalType=binary&status=done&style=none)


第6次跑, 让5个第一名跑,  的出第一名


![](https://youpaiyun.zongqilive.cn/image/20210514100317.png#id=oWMo7&originHeight=132&originWidth=461&originalType=binary&status=done&style=none)


第七次跑


![](https://youpaiyun.zongqilive.cn/image/20210514100328.png#id=MSA4U&originHeight=559&originWidth=476&originalType=binary&status=done&style=none)


Top k 的问题


# 海量大数据处理相关

参考: https://blog.csdn.net/v_JULY_v/article/details/6279498

## 题目1
>  提取出某日访问百度次数最多的那个IP

   a. 首先将大文件映射为1000个小文件, 例如 模1000

   b. 再找出每个小文中出现频率最大的IP, 可以采用hash_map进行频率统计，然后再找出频率最大的几个

   c. 然后再在这1000个最大的IP中，找出那个频率最大的IP(可以利用排序),即为所求

> 分而治之/hash映射 + hash统计 + 堆/快速/归并排序；

## 题目2

> 获取最热门的10个查询 字符 (典型的Top K算法)

1. 先对这批海量数据预处理，在O(n)的时间内用Hash表完成统计
2. 借助堆这个数据结构，找出Top K，时间复杂度为N(logK)

   

## 题目3

> 在2.5亿个整数中找出不重复的整数, **注，内存不足以容纳这2.5亿个整数**

利用位图法(Bitmap)

我们用 2 个 bit 来表示各个数字的状态：

- 00 表示这个数字没出现过；
- 01 表示这个数字出现过一次（即为题目所找的不重复整数）；
- 10 表示这个数字出现了多次。

共需内存 2^32 * 2 bit=1 GB内存。因此，当可用内存超过 1GB 时，可以采用位图法。假设内存满足位图法需求，进行下面的操作：

遍历 2.5 亿个整数，查看位图中对应的位，如果是 00，则变为 01，如果是 01 则变为 10，如果是 10 则保持不变。遍历结束后，查看位图，把对应位是 01 的整数输出即可。

> **判断数字是否重复的问题**，位图法是一种非常高效的方法。

## 题目4

> 100w个数中找出最大的100个数

方案1：用一个含100个元素的最小堆完成。复杂度为O(100w*lg100)。

方案2：采用快速排序的思想，每次分割之后只考虑比轴大的一部分，知道比轴大的一部分在比100多的时候，采用传统排序算法排序，取前100个。复杂度为O(100w*100)。

方案3：采用局部淘汰法。选取前100个元素，并排序，记为序列L。然后一次扫描剩余的元素x，与排好序的100个元素中最小的元素比，如果比这个最小的要大，那么把这个最小的元素删除，并把x利用插入排序的思想，插入到序列L中。依次循环，知道扫描了所有的元素。复杂度为O(100w*100)。


# shell统计日志

