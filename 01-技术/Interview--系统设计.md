





## 支付订单防止重复提交

![](https://youpaiyun.zongqilive.cn/image/20210602100122.png)

由于③⑤造成的掉单称之为外部掉单，由④⑥造成的掉单我们称之为内部掉单

为了防止订单重复提交，可以这样处理：
创建订单的时候，用订单信息计算一个哈希值，判断redis中是否有key，有则不允许重复提交，没有则生成一个新key，放到redis中设置个过期时间，然后创建订单。其实就是在一段时间内不可重复相同的操作

为了防止掉单，这里可以这样处理:
1、 支付订单增加一个中间状态“支付中”，当同一个订单去支付的时候，先检查有没有状态为“支付中”的支付流水，当然支付（prepay）的时候要加个锁。支付完成以后更新支付流水状态的时候再讲其改成“支付成功”状态。

2、 支付中心这边要自己定义一个超时时间（比如：30秒），在此时间范围内如果没有收到支付成功回调，则应调用接口主动查询支付结果，比如10s、20s、30s查一次，如果在最大查询次数内没有查到结果，应做异常处理

3、 支付中心收到支付结果以后，将结果同步给业务系统，可以发MQ，也可以直接调用，直接调用的话要加重试（比如：SpringBoot Retry）

4、 无论是支付中心，还是业务应用，在接收支付结果通知时都要考虑接口幂等性，消息只处理一次，其余的忽略
5、 业务应用也应做超时主动查询支付结果
对于上面说的超时主动查询可以在发起支付的时候将这些支付订单放到一张表中，用定时任务去扫





微信支付最佳实践：

![](https://youpaiyun.zongqilive.cn/image/20210602100634.png)









后端程序设计题：日uv两千万，设计一个投票系统，要求限制每个用户任意十分钟内只能投五票。给出系统设计以及需要资源情况。

# 接口幂等性

效果：系统对某接口的多次请求，都应该返回同样的结果！（网络访问失败的场景除外）

目的：避免因为各种原因，重复请求导致的业务重复处理

幂等性的实现方式

实现方法：客户端做某一请求的时候带上识别参数标识，服务端对此标识进行识别，重复请求则重复返回第一次的结果即可。

举个栗子：比如添加请求的表单里，在打开添加表单页面的时候，就生成一个AddId标识，这个AddId跟着表单一起提交到后台接口。

后台接口根据这个AddId，服务端就可以进行缓存标记并进行过滤，缓存值可以是AddId作为缓存key，返回内容作为缓存Value，这样即使添加按钮被多次点下也可以识别出来。

这个AddId什么时候更新呢？只有在保存成功并且清空表单之后，才变更这个AddId标识，从而实现新数据的表单提交


# 单点登录实现

[https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247483960&idx=1&sn=d6502108ecd21d1f923da420d8e0f3aa&chksm=e80db44edf7a3d580b2af7c167c1c2102d258657ef7964ba7947e28059a7d1faca6cb841d48a&scene=21#wechat_redirect](https://mp.weixin.qq.com/s?__biz=MzIyNDU2ODA4OQ==&mid=2247483960&idx=1&sn=d6502108ecd21d1f923da420d8e0f3aa&chksm=e80db44edf7a3d580b2af7c167c1c2102d258657ef7964ba7947e28059a7d1faca6cb841d48a&scene=21#wechat_redirect&fileGuid=xyjwRTK9vxw9wjGG)





